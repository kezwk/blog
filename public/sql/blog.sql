/*
Navicat MySQL Data Transfer

Source Server         : local
Source Server Version : 50553
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50553
File Encoding         : 65001

Date: 2019-09-27 16:26:39
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) DEFAULT NULL,
  `category_id` tinyint(10) DEFAULT '0',
  `visitable` tinyint(1) DEFAULT '0',
  `content` longtext,
  `markdown_code` longtext,
  `deleted` int(1) DEFAULT '1',
  `update` int(11) DEFAULT NULL,
  `created` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=30 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', 'Kaleoz-store前后端分离API设计', '1', '1', '<p><em><em><em><em><br>Kaleoz-store v2版本实现前后端分离以取代原kaloez-store由PHP输出html的方式。原Kaleos-store中PHP的业务逻辑改由API实现。\n<p>&gt; <em> 由于前后端分离，前台改用API获取数据<br>>  前后台所需数据结构不同，后台直接使用了Model返回需要的数据结构<br>&gt; <em> 后台数据结构不能满足前台需求<br>>  故前台数据改用Service处理<br>> * 前台Service命名约定以Store为前缀\n<p>Service的继承关系，以获取游戏数据的StoreGameService为例，如下：</p>\n<p>```<br>// 为子类service提供model及共用方法<br>class ModelService extends Tuki_Model<br>{\n<p>}</p>\n<p>// 为前台提供游戏相关数据<br>class StoreGameService extends ModelService<br>{\n<pre><code>public static function getGameById($gameId)\n{\n    self::getConn()-&amp;gt;from(\'game\')\n        -&amp;gt;joinLeft(\'language\', \'l.code=g.language\', \'name AS language\')\n        -&amp;gt;joinLeft(\'platform\', \'p.code=g.platform\', \'name AS platform\')\n        -&amp;gt;joinLeft(\'company\', \'c.id=g.publisher_id\', \'name AS publisher\');\n    self::getConn()-&amp;gt;where(\'g.id=?\', $gameId);\n    return self::getConn()-&amp;gt;limit(1)-&amp;gt;select()-&amp;gt;fetch();\n}\n</code></pre><p>}</p>\n<p>```</p></em></em></em></p>\n', '<em><em><em><em>\nKaleoz-store v2版本实现前后端分离以取代原kaloez-store由PHP输出html的方式。原Kaleos-store中PHP的业务逻辑改由API实现。\n\n&gt; * 由于前后端分离，前台改用API获取数据\n&gt; * 前后台所需数据结构不同，后台直接使用了Model返回需要的数据结构\n&gt; * 后台数据结构不能满足前台需求\n&gt; * 故前台数据改用Service处理\n&gt; * 前台Service命名约定以Store为前缀\n\nService的继承关系，以获取游戏数据的StoreGameService为例，如下：\n\n```\n// 为子类service提供model及共用方法\nclass ModelService extends Tuki_Model\n{\n\n}\n\n// 为前台提供游戏相关数据\nclass StoreGameService extends ModelService\n{\n\n    public static function getGameById($gameId)\n    {\n        self::getConn()-&gt;from(\'game\')\n            -&gt;joinLeft(\'language\', \'l.code=g.language\', \'name AS language\')\n            -&gt;joinLeft(\'platform\', \'p.code=g.platform\', \'name AS platform\')\n            -&gt;joinLeft(\'company\', \'c.id=g.publisher_id\', \'name AS publisher\');\n        self::getConn()-&gt;where(\'g.id=?\', $gameId);\n        return self::getConn()-&gt;limit(1)-&gt;select()-&gt;fetch();\n    }\n\n}\n\n```</em></em></em></em>', '0', '1569484196', '1568015500');
INSERT INTO `article` VALUES ('5', 'test', '2', '0', '<p>te</p>\n', 'te', '0', null, '1568087318');
INSERT INTO `article` VALUES ('2', 'PHP-PSR-[0-4]代码规范', '1', '1', '<p>PSR-0 (Autoloading Standard) 自动加载标准<br>PSR-1 (Basic Coding Standard) 基础编码标准<br>PSR-2 (Coding Style Guide) 编码风格向导<br>PSR-3 (Logger Interface) 日志接口<br>PSR-4(Improved Autoloading) 自动加载的增强版，可以替换掉PSR-0了。\n<hr>\n<p>PSR-0</p>\n<blockquote>\n<ol>\n<li>完全限定的命名空间和类必须具有以下结构 \\<Vendor Name>(<Namespace>)*<class name=\"\"></class><li>每个名称空间必须具有顶级名称空间（”Vendor Name”）。</li><li>每个命名空间可以包含任意数量的子命名空间。</li><li>每个命名空间分隔符DIRECTORY_SEPARATOR在从文件系统加载时转换为。</li><li>每一个<em>字符都转换为DIRECTORY_SEPARATOR。该</em>字符在命名空间中没有特殊含义。</li><li>.php从文件系统加载时，以.php结尾。</li><li>vendor，namespace和class名称中的字母字符可以是小写字母和大写字母的任意组合。</li></ol>\n</blockquote>\n<p>例子：</p>\n<blockquote>\n<p>\\Doctrine\\Common\\IsolatedClassLoader =&gt; /path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php<br>\\Symfony\\Core\\Request =&gt; /path/to/project/lib/vendor/Symfony/Core/Request.php<br>\\Zend\\Acl =&gt; /path/to/project/lib/vendor/Zend/Acl.php<br>\\Zend\\Mail\\Message => /path/to/project/lib/vendor/Zend/Mail/Message.php\n</blockquote>\n<p><strong>namespace和class中的下划线：</strong></p>\n<blockquote>\n<p>\\namespace\\package\\Class_Name =&gt; /path/to/project/lib/vendor/namespace/package/Class/Name.php</p>\n<p>\\namespace\\package_name\\Class_Name =&gt; /path/to/project/lib/vendor/namespace/package_name/Class/Name.php<br>```<br>function autoload($className){\n</blockquote>\n<p>$className=ltrim($className,’\\‘);</p>\n<p>$fileName=’’;</p>\n<p>$namespace=’’;</p>\n<p>if($lastNsPos=strrpos($className,’\\‘){</p>\n<p>$namespace=substr($className,0,$lastNsPos);</p>\n<p>$className=substr($className,$lastNsPos+1);</p>\n<p>$fileName=str_replace(‘\\‘,DIRECTORY_SEPARATOR,$namespace).DIRECTORY_SEPARATOR;</p>\n<p>}</p>\n<p>$fileName.=str<em>replace(‘</em>‘,DIRECTORY_SEPARATOR,$className).’.php’;</p>\n<p>require$fileName;</p>\n<p>}</p>\n<p>spl_autoload_register(‘autoload’);</p>\n<p>```</p>\n<p>PSR-4</p>\n<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”</p>\n<p>概述：此PSR描述了从文件路径<a href=\"http://php.net/autoload\">自动加载</a>类的规范。它完全可互操作，除了包括<a href=\"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md\">PSR-0</a>在内的任何其他自动加载规范外，还可以使用它。此PSR还描述了根据规范放置将自动加载的文件的位置</p>\n<ol>\n<li>术语“类”指的是类，接口，特征和其他类似结构。</li><li>完全限定的类名具有以下形式：<br>\\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName><ol>\n<li>完全限定的类名必须具有顶级命名空间名称，也称为“供应商命名空间”。</li><li>完全限定的类名可以具有一个或多个子命名空间名称。</li><li>完全限定的类名必须具有终止类名。</li><li>下划线在完全限定类名的任何部分都没有特殊含义。</li><li>完全限定类名中的字母字符可以是小写和大写的任意组合。</li><li>必须以区分大小写的方式引用所有类名。</li></ol>\n</li><li>加载对应于完全限定类名的文件时…<ol>\n<li>完全限定类名称（“名称空间前缀”）中的一个或多个前导命名空间和子命名空间名称的连续系列（不包括前导命名空间分隔符）对应于至少一个“基本目录”。</li><li>“名称空间前缀”之后的连续子命名空间名称对应于“基本目录”中的子目录，其中名称空间分隔符表示目录分隔符。子目录名称必须与子命名空间名称的大小写相匹配。</li><li>终止类名对应于以.php。结尾的文件名。文件名必须与终止类名称的大小写相匹配。</li></ol>\n</li><li>Autoloader实现绝不能抛出异常，不得引发任何级别的错误，并且不应该返回值。</li></ol>\n<p>Examples</p>\n<table>\n<thead>\n<tr>\n<th>FULLY QUALIFIED CLASS NAME</th>\n<th>NAMESPACE PREFIX</th>\n<th>BASE DIRECTORY</th>\n<th>RESULTING FILE PATH</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\Acme\\Log\\Writer\\File_Writer</td>\n<td>Acme\\Log\\Writer</td>\n<td>./acme-log-writer/lib/</td>\n<td>./acme-log-writer/lib/File_Writer.php</td>\n</tr>\n<tr>\n<td>\\Aura\\Web\\Response\\Status</td>\n<td>Aura\\Web</td>\n<td>/path/to/aura-web/src/</td>\n<td>/path/to/aura-web/src/Response/Status.php</td>\n</tr>\n<tr>\n<td>\\Symfony\\Core\\Request</td>\n<td>Symfony\\Core</td>\n<td>./vendor/Symfony/Core/</td>\n<td>./vendor/Symfony/Core/Request.php</td>\n</tr>\n<tr>\n<td>\\Zend\\Acl</td>\n<td>Zend</td>\n<td>/usr/includes/Zend/</td>\n<td>/usr/includes/Zend/Acl.php</td>\n</tr>\n</tbody>\n</table>\n<p>For example implementations of autoloaders conforming to the specification, please see the <a href=\"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md\">examples file</a>. Example implementations MUST NOT be regarded as part of the specification and MAY change at any time.</p>\n<p>参考 ： <a href=\"https://www.php-fig.org/psr\">https://www.php-fig.org/psr</a><br>参考： <a href=\"https://www.cnblogs.com/52php/p/5852572.html\">https://www.cnblogs.com/52php/p/5852572.html</a></p>\n', 'PSR-0 (Autoloading Standard) 自动加载标准  \nPSR-1 (Basic Coding Standard) 基础编码标准\nPSR-2 (Coding Style Guide) 编码风格向导\nPSR-3 (Logger Interface) 日志接口\nPSR-4(Improved Autoloading) 自动加载的增强版，可以替换掉PSR-0了。\n* * *\n\nPSR-0\n\n> 1. 完全限定的命名空间和类必须具有以下结构 \\<Vendor Name>\\(<Namespace>\\)*<Class Name>\n> 2. 每个名称空间必须具有顶级名称空间（\"Vendor Name\"）。\n> 3. 每个命名空间可以包含任意数量的子命名空间。\n> 4. 每个命名空间分隔符DIRECTORY_SEPARATOR在从文件系统加载时转换为。\n> 5.  每一个_字符都转换为DIRECTORY_SEPARATOR。该_字符在命名空间中没有特殊含义。\n> 6. .php从文件系统加载时，以.php结尾。\n> 7. vendor，namespace和class名称中的字母字符可以是小写字母和大写字母的任意组合。\n\n例子：\n\n> \\Doctrine\\Common\\IsolatedClassLoader => /path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php\n> \\Symfony\\Core\\Request => /path/to/project/lib/vendor/Symfony/Core/Request.php\n> \\Zend\\Acl => /path/to/project/lib/vendor/Zend/Acl.php\n> \\Zend\\Mail\\Message => /path/to/project/lib/vendor/Zend/Mail/Message.php\n\n**namespace和class中的下划线：**\n\n> \\namespace\\package\\Class_Name => /path/to/project/lib/vendor/namespace/package/Class/Name.php\n> \n> \\namespace\\package_name\\Class_Name => /path/to/project/lib/vendor/namespace/package_name/Class/Name.php\n```\nfunction autoload($className){\n\n$className=ltrim($className,\'\\\\\');\n\n$fileName=\'\';\n\n$namespace=\'\';\n\nif($lastNsPos=strrpos($className,\'\\\\\'){\n\n$namespace=substr($className,0,$lastNsPos);\n\n$className=substr($className,$lastNsPos+1);\n\n$fileName=str_replace(\'\\\\\',DIRECTORY_SEPARATOR,$namespace).DIRECTORY_SEPARATOR;\n\n}\n\n$fileName.=str_replace(\'_\',DIRECTORY_SEPARATOR,$className).\'.php\';\n\nrequire$fileName;\n\n}\n\nspl_autoload_register(\'autoload\');\n\n```\n\nPSR-4\n\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”\n\n概述：此PSR描述了从文件路径[自动加载](http://php.net/autoload)类的规范。它完全可互操作，除了包括[PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md)在内的任何其他自动加载规范外，还可以使用它。此PSR还描述了根据规范放置将自动加载的文件的位置\n\n\n1. 术语“类”指的是类，接口，特征和其他类似结构。\n2. 完全限定的类名具有以下形式：\n \\<NamespaceName>(\\<SubNamespaceNames>)*\\<ClassName>\n     1. 完全限定的类名必须具有顶级命名空间名称，也称为“供应商命名空间”。\n     2. 完全限定的类名可以具有一个或多个子命名空间名称。\n     3. 完全限定的类名必须具有终止类名。\n     4. 下划线在完全限定类名的任何部分都没有特殊含义。\n     5. 完全限定类名中的字母字符可以是小写和大写的任意组合。\n     6. 必须以区分大小写的方式引用所有类名。\n3. 加载对应于完全限定类名的文件时...\n    1. 完全限定类名称（“名称空间前缀”）中的一个或多个前导命名空间和子命名空间名称的连续系列（不包括前导命名空间分隔符）对应于至少一个“基本目录”。\n    2. “名称空间前缀”之后的连续子命名空间名称对应于“基本目录”中的子目录，其中名称空间分隔符表示目录分隔符。子目录名称必须与子命名空间名称的大小写相匹配。\n    3. 终止类名对应于以.php。结尾的文件名。文件名必须与终止类名称的大小写相匹配。\n4. Autoloader实现绝不能抛出异常，不得引发任何级别的错误，并且不应该返回值。\n\nExamples\n\n| FULLY QUALIFIED CLASS NAME | NAMESPACE PREFIX | BASE DIRECTORY | RESULTING FILE PATH |\n| --- | --- | --- | --- |\n| \\Acme\\Log\\Writer\\File_Writer | Acme\\Log\\Writer | ./acme-log-writer/lib/ | ./acme-log-writer/lib/File_Writer.php |\n| \\Aura\\Web\\Response\\Status | Aura\\Web | /path/to/aura-web/src/ | /path/to/aura-web/src/Response/Status.php |\n| \\Symfony\\Core\\Request | Symfony\\Core | ./vendor/Symfony/Core/ | ./vendor/Symfony/Core/Request.php |\n| \\Zend\\Acl | Zend | /usr/includes/Zend/ | /usr/includes/Zend/Acl.php |\n\nFor example implementations of autoloaders conforming to the specification, please see the [examples file](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md). Example implementations MUST NOT be regarded as part of the specification and MAY change at any time.\n\n\n参考 ： [https://www.php-fig.org/psr](https://www.php-fig.org/psr)\n参考： [https://www.cnblogs.com/52php/p/5852572.html](https://www.cnblogs.com/52php/p/5852572.html)\n', '1', null, '1568018100');
INSERT INTO `article` VALUES ('3', 'composer添加自定义类文件', '1', '1', '<p>1.在composer.json添加如下配置：</p>\n<pre><code>    \"autoload\": {\n        \"classmap\":[\n            \"application/index/service\"\n        ],\n        \"psr-4\": {\n            \"app\\\\\": \"application\"\n        }\n    },\n</code></pre><p>2.使用composer dump<br>在vendoer\\composer\\autoload_classmap.php下生成对应路径：<br>在”classmap”对应的数组中添加需要自动加载的目录,composer将会将目录中所有的类按照 “namespace + classname => base.dir.设置的路径” 的形式生成成一个 key => value 的数组。(ps:base.dir就是我们的工程所在的目录)\n<pre><code>return array(\n    \'IndexService\' =&gt; $baseDir . \'/application/index/service/IndexService.php\',\n);\n</code></pre>', '1.在composer.json添加如下配置：\n```\n    \"autoload\": {\n        \"classmap\":[\n            \"application/index/service\"\n        ],\n        \"psr-4\": {\n            \"app\\\\\": \"application\"\n        }\n    },\n```\n2.使用composer dump\n在vendoer\\composer\\autoload_classmap.php下生成对应路径：\n在”classmap”对应的数组中添加需要自动加载的目录,composer将会将目录中所有的类按照 “namespace + classname => base.dir.设置的路径” 的形式生成成一个 key => value 的数组。(ps:base.dir就是我们的工程所在的目录)\n```\nreturn array(\n    \'IndexService\' => $baseDir . \'/application/index/service/IndexService.php\',\n);\n```', '1', null, '1568014800');
INSERT INTO `article` VALUES ('6', 'test', '2', '1', '<p>test</p>\n', 'test', '0', null, '1568099584');
INSERT INTO `article` VALUES ('7', 'test', '3', '1', '<p>tata</p>\n', 'tata', '0', null, '1568105521');
INSERT INTO `article` VALUES ('8', 'test', '3', '1', '<p>tata</p>\n', 'tata', '0', null, '1568105576');
INSERT INTO `article` VALUES ('9', 'test', '3', '0', '<p>tata</p>\n', 'tata', '0', null, '1568105599');
INSERT INTO `article` VALUES ('10', 'test', '5', '1', '<p>aaa</p>\n', 'aaa', '0', null, '1568105816');
INSERT INTO `article` VALUES ('11', 'test', '5', '1', '<p>aaa</p>\n', 'aaa', '0', null, '1568105819');
INSERT INTO `article` VALUES ('12', 'test', '5', '1', '<p>aaa</p>\n', 'aaa', '0', null, '1568105855');
INSERT INTO `article` VALUES ('13', 'test', '5', '1', '<p>aaa</p>\n', 'aaa', '0', null, '1568105882');
INSERT INTO `article` VALUES ('14', 'test', '1', '0', '<p>a</p>\n', 'a', '0', null, '1568105894');
INSERT INTO `article` VALUES ('15', 'PHP细节随笔', '1', '1', '<h4 id=\"h4-php7-\"><a name=\"PHP7中？？与？：的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP7中？？与？：的区别</h4><p><code>??</code> $b = $a?? $c ;相当于$b= isset($a)?$a:$c<br><code>?:</code> $b = $a?$a:&nbsp;$c 则是&nbsp;$b&nbsp;= ！empty($a) ?&nbsp;$a:$c;</p>\n<h4 id=\"h4-file_get_contents\"><a name=\"file_get_contents\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>file_get_contents</h4><p>php接受json：[{“id”:26,”name”:”经常问的问题！”},{“id”:27,”name”:”Soalan Lazim！”}]<br>时候要使用file_get_contents(‘php://input’)<br>接受文本也可以使用file_get_contents和如下fp:\n<pre><code>$file_path=\"text.txt\";\nif(file_exits(file_path)){\n    $fp=fopen($file_path,\'r\');\n    $str=fread($fp,filesize($file_path));\n    echo $str=str_replace(\"\\r\\n\",&lt;br&gt;,$str);\n}\n</code></pre><h4 id=\"h4-strip_tags-html-\"><a name=\"Strip_tags去掉html标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Strip_tags去掉html标签</h4><h4 id=\"h4-composer\"><a name=\"composer\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>composer</h4><p>Composer search；<br>Composer require；<br>Composer dump-autoload；重新产生map<br>Composer autoload —加载composer.json里面的依赖\n<h4 id=\"h4-isset-empty-\"><a name=\"isset empty区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>isset empty区别</h4><p><strong>PHP的isset()函数 一般用来检测变量是否设置</strong><br>格式：bool isset ( mixed var [, mixed var [, …]] )；<br>功能：检测变量是否设置 ；<br><strong>PHP的empty()函数 判断值为否为空</strong><br>格式：bool empty ( mixed var ) ；<br>功能：检查一个变量是否为空 ；\n<h4 id=\"h4-a-non-well-formed-numeric-value-encountered\"><a name=\"A non well formed numeric value encountered\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>A non well formed numeric value encountered</h4>', '#### PHP7中？？与？：的区别\n`??` $b = $a?? $c ;相当于$b= isset($a)?$a:$c\n`?:` $b = $a?$a:&nbsp;$c 则是&nbsp;$b&nbsp;= ！empty($a) ?&nbsp;$a:$c;\n#### file_get_contents\nphp接受json：[{\"id\":26,\"name\":\"经常问的问题！\"},{\"id\":27,\"name\":\"Soalan Lazim！\"}]\n时候要使用file_get_contents(\'php://input\')\n接受文本也可以使用file_get_contents和如下fp:\n```\n$file_path=\"text.txt\";\nif(file_exits(file_path)){\n	$fp=fopen($file_path,\'r\');\n	$str=fread($fp,filesize($file_path));\n	echo $str=str_replace(\"\\r\\n\",<br>,$str);\n}\n```\n#### Strip_tags去掉html标签\n\n#### composer\nComposer search；\nComposer require；\nComposer dump-autoload；重新产生map\nComposer autoload --加载composer.json里面的依赖\n#### isset empty区别\n**PHP的isset()函数 一般用来检测变量是否设置**\n格式：bool isset ( mixed var [, mixed var [, ...]] )；\n功能：检测变量是否设置 ；\n**PHP的empty()函数 判断值为否为空**\n格式：bool empty ( mixed var ) ；\n功能：检查一个变量是否为空 ；\n#### A non well formed numeric value encountered \n', '1', '1569484187', '1569470204');
INSERT INTO `article` VALUES ('16', 'PHP常用的字符串函数', '1', '0', '<h4 id=\"h4--\"><a name=\"一、判断类型的函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、判断类型的函数</h4><pre><code>is_bool()    //判断是否为布尔型\nis_float()   //判断是否为浮点型\nis_real()    //同上\nis_int()    //判断是否为整型\nis_integer()  //同上\nis_string()   //判断是否为字符串\nis_object()   //判断是否为对象\nis_array()   //判断是否为数组\nis_null()    //判断是否为null\nis_file()    //判断是否为文件\nis_dir()    //判断是否为目录\nis_numeric()  //判断是否为数字\nis_nan()    //判断不是数字\nis_resource()  //判断是否为资源类型\nis_a($obj,$classname) //判断对象是否为类的实例可用 if($obj instanceof Classname）\n</code></pre><h4 id=\"h4--\"><a name=\"二、获取子串位置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、获取子串位置</h4><pre><code>strpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置。 \nstripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置, 不区分大小写。\nstrrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置。\nstrripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置,不区分大小写。\n</code></pre><h4 id=\"h4--\"><a name=\"三、获取子串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、获取子串</h4><pre><code>substr($str,$start [,$length]); //获取子串\nsubstr_compare($main_str,$str,$offset[,$length]); //子串比较 从offset处开始比较\nsubstr_count($hs,$nd [,$offset=0 [,$length]]); //获取子串nd在hs中出现的次数\nsubstr_replace($string,$replacement,$start [,$length]); //字符串子串替换\n                //用$replacement替换掉$string从start开始长度为length的子串\nstrstr($hys,$nd [,bool $before_needle = false ]);//返回$nd在$hys 第一次出现的地方开始到字符串结束 为止的字符串\n        //第三个参数如果为true 则返回$nd 之前的字符串\nstristr($hys,$nd [,bool $before_needle = false ]); //同上，忽略大小写版本\nstrrchr($hys,$nd); //返回$nd在$hys最后一次出现的地方开始到字符串结束 为止的字符串\n        //一般和 substr(strrchr($hys,$nd),strlen($nd)); 合用\nstrpbrk($haystack,$char_list);//从$char_list中依次匹配单个字符在$haystack中第一次出现的地方\n            //到字符串结束的地方 的整个字符串\nstrtok($str,$token); //第一次使用 将字符串按分隔符$token进行分割\nstrtok($token);   //第二次使用\n    eg.\n    $string = \"This is\\tan example\\nstring\";\n    /* 使用制表符和换行符作为分界符 */\n    $tok = strtok($string, \" \\n\\t\");\n\n    while ($tok !== false) {\n        echo \"Word=$tok&lt;br /&gt;\";\n        $tok = strtok(\" \\n\\t\");\n    }\n</code></pre><h4 id=\"h4--str_-\"><a name=\"字符串str_ 型函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>字符串str_ 型函数</h4><pre><code>str_getcsv($str); //将csv文件字符串转换成一个数组\nstr_replace($search,$replace,$subject [,&amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数\nstr_ireplace($search,$replace,$subject [,&amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数 忽略大小写\nstr_shuffle(string $str);//随机打乱字符串\nstr_split($str [,$len=1]);//将字符串转换成一个数组\n             //，每个数组单元的长度为$len\n</code></pre><h4 id=\"h4--\"><a name=\"五、字符串长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、字符串长度</h4><pre><code>strlen($str); //字符串长度\n</code></pre><h4 id=\"h4--\"><a name=\"六、翻转字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、翻转字符串</h4><pre><code>strrev(string $string);// 翻转字符串\n</code></pre><h4 id=\"h4--mb_-\"><a name=\"七、mb_类型字符串函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、mb_类型字符串函数</h4><p>mb_类型字符串与上述字符串函数基本一样，<br>只是加多一个可选的字符编码参数，用法同上<br>这里列出一些其他有用函数\n<pre><code>$encode = mb_detect_encoding($lines, array(\"ASCII\",\"UTF-8\",\"GB2312\",\"GBK\",\"BIG5\"));\nif($encode != \"UTF-8\"){\n  $lines = iconv($encode,\"UTF-8\", $lines);\n}\n</code></pre><h4 id=\"h4--\"><a name=\"八、字符串的相关操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、字符串的相关操作</h4><p>1、转换字符串类型</p>\n<pre><code>strval($str); //转换成字符串类型\nfloatval($str);//转换成浮点型\nintval($str); //转换成整型\n</code></pre><p>2、大小写转换</p>\n<pre><code>strtolower($str); //全部转换成小写\nstrtoupper($str); //全部转换成大写\n</code></pre><p>3、字符串转时间戳</p>\n<pre><code>strtotime($str); //时间格式的字符串转换成整型时间戳\n      //注意设置时区 否则会有 8小时误差\n</code></pre><p>4、去除HTML 和 PHP 标记</p>\n<pre><code>strip_tags($str [,$tags]);//去除不含$tags里标签外的所有标签\n</code></pre><p>5、ascii转数字 数字转ascii</p>\n<pre><code>chr(int $ascii); //数字转换成ascii\nord(string $str); //返回$str第一个字符的ascii值\n</code></pre><p>6、json的编码与解码</p>\n<pre><code>json_encode($obj/$arr/$str...);//编码成json 格式的字符串\njson_decode($jsonstr [,$assoc=true]); //解码成对象\n             //当$assoc=true 时 返回数组 而非对象\n</code></pre><p>7、换行转<br>\n<pre><code>nl2br($str); //字符串 $str 所有新行之前插入\'&lt;br/&gt;\'\n</code></pre><p>8、数组转字符串，字符串转数组</p>\n<pre><code>implode($arr,$glue);//将一维数组转换为字符串\nexplode();//字符串转换为数组\n</code></pre><p>9、千位分割格式化</p>\n<pre><code>string number_format ( float $number [, int $decimals = 0 ] )\nstring number_format ( float $number , int $decimals = 0 , string $dec_point = \'.\' , string $thousands_sep = \',\' )\n @param  $number 你要格式化的数字 \n     $decimals 要保留的小数位数 \n     $dec_point 指定小数点显示的字符 \n     $thousands_sep 指定千位分隔符显示的字符\n</code></pre><p>10、去空格</p>\n<pre><code>trim(string $str [,string $charlist ]); //去左右字符\nltrim(string $str [,string $charlist ]); //去左字符\nrtrim(string $str [,string $charlist ]); //去右字符\n</code></pre><p>该函数删除 str 末端的空白字符并返回。</p>\n<p>不使用第二个参数， rtrim() 仅删除以下字符：<br>• “ “ (ASCII 32 (0x20))，普通空白符。<br>• “\\t” (ASCII 9 (0x09))，制表符。<br>• “\\n” (ASCII 10 (0x0A))，换行符。<br>• “\\r” (ASCII 13 (0x0D))，回车符。<br>• “\\0” (ASCII 0 (0x00))，NUL 空字节符。<br>• “\\x0B” (ASCII 11 (0x0B))，垂直制表符。<br>过滤字符也可由 charlist 参数指定。一般要列出所有希望过滤的字符，<br>也可以使用 “..” 列出一个字符范围<br>11、转换字符串编码函数\n<pre><code>iconv($in_charset, $out_charset, $str);\n$in_charset输入字符集\n$out_charset输出字符集\n</code></pre><p>12、字符串加密函数</p>\n<pre><code>sha1($str);\nmd5($str);\n</code></pre><p>13、字符串转义与反转义函数</p>\n<pre><code>addcslashes(string $str , string $charlist);//转义字符串中的特殊字符\n        //eg. addcslashes($str,\"\\0..\\37!@\\177..\\377\");\n              //转义ascii 中0-37、177-377中不含@符号的字符\n\nstripcslashes($str) — 反转义addcslashes()函数转义处理过的字符串\n 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，... 八进制以及十六进制的描述\n</code></pre><p>14、按格式返回数据</p>\n<pre><code>sprintf — 按照要求对数据进行返回，但是不输出\n    可表示类型如下：\n    string s \n    integer d, u, c, o, x, X, b \n    double g, G, e, E, f, F \n    eg.\n    $num = 5;\n    $location = \'tree\';\n    $format = \'There are %d monkeys in the %s\';\n    echo sprintf($format, $num, $location);\n</code></pre>', '#### 一、判断类型的函数\n```\nis_bool()    //判断是否为布尔型\nis_float()   //判断是否为浮点型\nis_real()    //同上\nis_int()    //判断是否为整型\nis_integer()  //同上\nis_string()   //判断是否为字符串\nis_object()   //判断是否为对象\nis_array()   //判断是否为数组\nis_null()    //判断是否为null\nis_file()    //判断是否为文件\nis_dir()    //判断是否为目录\nis_numeric()  //判断是否为数字\nis_nan()    //判断不是数字\nis_resource()  //判断是否为资源类型\nis_a($obj,$classname) //判断对象是否为类的实例可用 if($obj instanceof Classname）\n```\n#### 二、获取子串位置\n```\nstrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置。 \nstripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置, 不区分大小写。\nstrrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置。\nstrripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置,不区分大小写。 \n```\n#### 三、获取子串\n```\nsubstr($str,$start [,$length]); //获取子串\nsubstr_compare($main_str,$str,$offset[,$length]); //子串比较 从offset处开始比较\nsubstr_count($hs,$nd [,$offset=0 [,$length]]); //获取子串nd在hs中出现的次数\nsubstr_replace($string,$replacement,$start [,$length]); //字符串子串替换\n                //用$replacement替换掉$string从start开始长度为length的子串\nstrstr($hys,$nd [,bool $before_needle = false ]);//返回$nd在$hys 第一次出现的地方开始到字符串结束 为止的字符串\n        //第三个参数如果为true 则返回$nd 之前的字符串\nstristr($hys,$nd [,bool $before_needle = false ]); //同上，忽略大小写版本\nstrrchr($hys,$nd); //返回$nd在$hys最后一次出现的地方开始到字符串结束 为止的字符串\n        //一般和 substr(strrchr($hys,$nd),strlen($nd)); 合用\nstrpbrk($haystack,$char_list);//从$char_list中依次匹配单个字符在$haystack中第一次出现的地方\n            //到字符串结束的地方 的整个字符串\nstrtok($str,$token); //第一次使用 将字符串按分隔符$token进行分割\nstrtok($token);   //第二次使用\n    eg.\n    $string = \"This is\\tan example\\nstring\";\n    /* 使用制表符和换行符作为分界符 */\n    $tok = strtok($string, \" \\n\\t\");\n  \n    while ($tok !== false) {\n        echo \"Word=$tok<br />\";\n        $tok = strtok(\" \\n\\t\");\n    }\n```\n#### 字符串str_ 型函数\n```\nstr_getcsv($str); //将csv文件字符串转换成一个数组\nstr_replace($search,$replace,$subject [,&$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数\nstr_ireplace($search,$replace,$subject [,&$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数 忽略大小写\nstr_shuffle(string $str);//随机打乱字符串\nstr_split($str [,$len=1]);//将字符串转换成一个数组\n             //，每个数组单元的长度为$len\n```\n####五、字符串长度\n```\nstrlen($str); //字符串长度\n```\n#### 六、翻转字符串\n\n```\nstrrev(string $string);// 翻转字符串\n```\n#### 七、mb_类型字符串函数\nmb_类型字符串与上述字符串函数基本一样，\n只是加多一个可选的字符编码参数，用法同上\n这里列出一些其他有用函数\n```\n$encode = mb_detect_encoding($lines, array(\"ASCII\",\"UTF-8\",\"GB2312\",\"GBK\",\"BIG5\"));\nif($encode != \"UTF-8\"){\n  $lines = iconv($encode,\"UTF-8\", $lines);\n}\n```\n#### 八、字符串的相关操作\n1、转换字符串类型\n```\nstrval($str); //转换成字符串类型\nfloatval($str);//转换成浮点型\nintval($str); //转换成整型\n```\n2、大小写转换\n```\nstrtolower($str); //全部转换成小写\nstrtoupper($str); //全部转换成大写\n```\n3、字符串转时间戳\n```\nstrtotime($str); //时间格式的字符串转换成整型时间戳\n      //注意设置时区 否则会有 8小时误差\n```\n4、去除HTML 和 PHP 标记\n```\nstrip_tags($str [,$tags]);//去除不含$tags里标签外的所有标签\n```\n5、ascii转数字 数字转ascii\n```\nchr(int $ascii); //数字转换成ascii\nord(string $str); //返回$str第一个字符的ascii值\n```\n6、json的编码与解码\n```\njson_encode($obj/$arr/$str...);//编码成json 格式的字符串\njson_decode($jsonstr [,$assoc=true]); //解码成对象\n             //当$assoc=true 时 返回数组 而非对象\n```\n7、换行转<br/>\n```\nnl2br($str); //字符串 $str 所有新行之前插入\'<br/>\'\n```\n8、数组转字符串，字符串转数组\n```\nimplode($arr,$glue);//将一维数组转换为字符串\nexplode();//字符串转换为数组\n```\n9、千位分割格式化\n```\nstring number_format ( float $number [, int $decimals = 0 ] )\nstring number_format ( float $number , int $decimals = 0 , string $dec_point = \'.\' , string $thousands_sep = \',\' )\n @param  $number 你要格式化的数字 \n     $decimals 要保留的小数位数 \n     $dec_point 指定小数点显示的字符 \n     $thousands_sep 指定千位分隔符显示的字符 \n```\n10、去空格\n```\ntrim(string $str [,string $charlist ]); //去左右字符\nltrim(string $str [,string $charlist ]); //去左字符\nrtrim(string $str [,string $charlist ]); //去右字符\n```\n该函数删除 str 末端的空白字符并返回。\n\n不使用第二个参数， rtrim() 仅删除以下字符：\n• \" \" (ASCII 32 (0x20))，普通空白符。\n• \"\\t\" (ASCII 9 (0x09))，制表符。\n• \"\\n\" (ASCII 10 (0x0A))，换行符。\n• \"\\r\" (ASCII 13 (0x0D))，回车符。\n• \"\\0\" (ASCII 0 (0x00))，NUL 空字节符。\n• \"\\x0B\" (ASCII 11 (0x0B))，垂直制表符。\n过滤字符也可由 charlist 参数指定。一般要列出所有希望过滤的字符，\n也可以使用 \"..\" 列出一个字符范围\n11、转换字符串编码函数\n```\niconv($in_charset, $out_charset, $str);\n$in_charset输入字符集\n$out_charset输出字符集\n```\n12、字符串加密函数\n```\nsha1($str);\nmd5($str);\n```\n13、字符串转义与反转义函数\n```\naddcslashes(string $str , string $charlist);//转义字符串中的特殊字符\n        //eg. addcslashes($str,\"\\0..\\37!@\\177..\\377\");\n              //转义ascii 中0-37、177-377中不含@符号的字符\n  \nstripcslashes($str) — 反转义addcslashes()函数转义处理过的字符串\n 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，... 八进制以及十六进制的描述\n```\n14、按格式返回数据\n```\nsprintf — 按照要求对数据进行返回，但是不输出\n    可表示类型如下：\n    string s \n    integer d, u, c, o, x, X, b \n    double g, G, e, E, f, F \n    eg.\n    $num = 5;\n    $location = \'tree\';\n    $format = \'There are %d monkeys in the %s\';\n    echo sprintf($format, $num, $location);\n```', '0', null, '1569481028');
INSERT INTO `article` VALUES ('17', 'PHP常用的字符串函数', '1', '0', '<h4 id=\"h4--\"><a name=\"一、判断类型的函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、判断类型的函数</h4><pre><code>is_bool()    //判断是否为布尔型\nis_float()   //判断是否为浮点型\nis_real()    //同上\nis_int()    //判断是否为整型\nis_integer()  //同上\nis_string()   //判断是否为字符串\nis_object()   //判断是否为对象\nis_array()   //判断是否为数组\nis_null()    //判断是否为null\nis_file()    //判断是否为文件\nis_dir()    //判断是否为目录\nis_numeric()  //判断是否为数字\nis_nan()    //判断不是数字\nis_resource()  //判断是否为资源类型\nis_a($obj,$classname) //判断对象是否为类的实例可用 if($obj instanceof Classname）\n</code></pre><h4 id=\"h4--\"><a name=\"二、获取子串位置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、获取子串位置</h4><pre><code>strpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置。 \nstripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置, 不区分大小写。\nstrrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置。\nstrripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置,不区分大小写。\n</code></pre><h4 id=\"h4--\"><a name=\"三、获取子串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、获取子串</h4><pre><code>substr($str,$start [,$length]); //获取子串\nsubstr_compare($main_str,$str,$offset[,$length]); //子串比较 从offset处开始比较\nsubstr_count($hs,$nd [,$offset=0 [,$length]]); //获取子串nd在hs中出现的次数\nsubstr_replace($string,$replacement,$start [,$length]); //字符串子串替换\n                //用$replacement替换掉$string从start开始长度为length的子串\nstrstr($hys,$nd [,bool $before_needle = false ]);//返回$nd在$hys 第一次出现的地方开始到字符串结束 为止的字符串\n        //第三个参数如果为true 则返回$nd 之前的字符串\nstristr($hys,$nd [,bool $before_needle = false ]); //同上，忽略大小写版本\nstrrchr($hys,$nd); //返回$nd在$hys最后一次出现的地方开始到字符串结束 为止的字符串\n        //一般和 substr(strrchr($hys,$nd),strlen($nd)); 合用\nstrpbrk($haystack,$char_list);//从$char_list中依次匹配单个字符在$haystack中第一次出现的地方\n            //到字符串结束的地方 的整个字符串\nstrtok($str,$token); //第一次使用 将字符串按分隔符$token进行分割\nstrtok($token);   //第二次使用\n    eg.\n    $string = \"This is\\tan example\\nstring\";\n    /* 使用制表符和换行符作为分界符 */\n    $tok = strtok($string, \" \\n\\t\");\n\n    while ($tok !== false) {\n        echo \"Word=$tok&lt;br /&gt;\";\n        $tok = strtok(\" \\n\\t\");\n    }\n</code></pre><h4 id=\"h4--str_-\"><a name=\"字符串str_ 型函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>字符串str_ 型函数</h4><pre><code>str_getcsv($str); //将csv文件字符串转换成一个数组\nstr_replace($search,$replace,$subject [,&amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数\nstr_ireplace($search,$replace,$subject [,&amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数 忽略大小写\nstr_shuffle(string $str);//随机打乱字符串\nstr_split($str [,$len=1]);//将字符串转换成一个数组\n             //，每个数组单元的长度为$len\n</code></pre><h4 id=\"h4--\"><a name=\"五、字符串长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、字符串长度</h4><pre><code>strlen($str); //字符串长度\n</code></pre><h4 id=\"h4--\"><a name=\"六、翻转字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、翻转字符串</h4><pre><code>strrev(string $string);// 翻转字符串\n</code></pre><h4 id=\"h4--mb_-\"><a name=\"七、mb_类型字符串函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、mb_类型字符串函数</h4><p>mb_类型字符串与上述字符串函数基本一样，<br>只是加多一个可选的字符编码参数，用法同上<br>这里列出一些其他有用函数\n<pre><code>$encode = mb_detect_encoding($lines, array(\"ASCII\",\"UTF-8\",\"GB2312\",\"GBK\",\"BIG5\"));\nif($encode != \"UTF-8\"){\n  $lines = iconv($encode,\"UTF-8\", $lines);\n}\n</code></pre><h4 id=\"h4--\"><a name=\"八、字符串的相关操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、字符串的相关操作</h4><p>1、转换字符串类型</p>\n<pre><code>strval($str); //转换成字符串类型\nfloatval($str);//转换成浮点型\nintval($str); //转换成整型\n</code></pre><p>2、大小写转换</p>\n<pre><code>strtolower($str); //全部转换成小写\nstrtoupper($str); //全部转换成大写\n</code></pre><p>3、字符串转时间戳</p>\n<pre><code>strtotime($str); //时间格式的字符串转换成整型时间戳\n      //注意设置时区 否则会有 8小时误差\n</code></pre><p>4、去除HTML 和 PHP 标记</p>\n<pre><code>strip_tags($str [,$tags]);//去除不含$tags里标签外的所有标签\n</code></pre><p>5、ascii转数字 数字转ascii</p>\n<pre><code>chr(int $ascii); //数字转换成ascii\nord(string $str); //返回$str第一个字符的ascii值\n</code></pre><p>6、json的编码与解码</p>\n<pre><code>json_encode($obj/$arr/$str...);//编码成json 格式的字符串\njson_decode($jsonstr [,$assoc=true]); //解码成对象\n             //当$assoc=true 时 返回数组 而非对象\n</code></pre><p>7、换行转<br>\n<pre><code>nl2br($str); //字符串 $str 所有新行之前插入\'&lt;br/&gt;\'\n</code></pre><p>8、数组转字符串，字符串转数组</p>\n<pre><code>implode($arr,$glue);//将一维数组转换为字符串\nexplode();//字符串转换为数组\n</code></pre><p>9、千位分割格式化</p>\n<pre><code>string number_format ( float $number [, int $decimals = 0 ] )\nstring number_format ( float $number , int $decimals = 0 , string $dec_point = \'.\' , string $thousands_sep = \',\' )\n @param  $number 你要格式化的数字 \n     $decimals 要保留的小数位数 \n     $dec_point 指定小数点显示的字符 \n     $thousands_sep 指定千位分隔符显示的字符\n</code></pre><p>10、去空格</p>\n<pre><code>trim(string $str [,string $charlist ]); //去左右字符\nltrim(string $str [,string $charlist ]); //去左字符\nrtrim(string $str [,string $charlist ]); //去右字符\n</code></pre><p>该函数删除 str 末端的空白字符并返回。</p>\n<p>不使用第二个参数， rtrim() 仅删除以下字符：<br>• “ “ (ASCII 32 (0x20))，普通空白符。<br>• “\\t” (ASCII 9 (0x09))，制表符。<br>• “\\n” (ASCII 10 (0x0A))，换行符。<br>• “\\r” (ASCII 13 (0x0D))，回车符。<br>• “\\0” (ASCII 0 (0x00))，NUL 空字节符。<br>• “\\x0B” (ASCII 11 (0x0B))，垂直制表符。<br>过滤字符也可由 charlist 参数指定。一般要列出所有希望过滤的字符，<br>也可以使用 “..” 列出一个字符范围<br>11、转换字符串编码函数\n<pre><code>iconv($in_charset, $out_charset, $str);\n$in_charset输入字符集\n$out_charset输出字符集\n</code></pre><p>12、字符串加密函数</p>\n<pre><code>sha1($str);\nmd5($str);\n</code></pre><p>13、字符串转义与反转义函数</p>\n<pre><code>addcslashes(string $str , string $charlist);//转义字符串中的特殊字符\n        //eg. addcslashes($str,\"\\0..\\37!@\\177..\\377\");\n              //转义ascii 中0-37、177-377中不含@符号的字符\n\nstripcslashes($str) — 反转义addcslashes()函数转义处理过的字符串\n 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，... 八进制以及十六进制的描述\n</code></pre><p>14、按格式返回数据</p>\n<pre><code>sprintf — 按照要求对数据进行返回，但是不输出\n    可表示类型如下：\n    string s \n    integer d, u, c, o, x, X, b \n    double g, G, e, E, f, F \n    eg.\n    $num = 5;\n    $location = \'tree\';\n    $format = \'There are %d monkeys in the %s\';\n    echo sprintf($format, $num, $location);\n</code></pre>', '#### 一、判断类型的函数\n```\nis_bool()    //判断是否为布尔型\nis_float()   //判断是否为浮点型\nis_real()    //同上\nis_int()    //判断是否为整型\nis_integer()  //同上\nis_string()   //判断是否为字符串\nis_object()   //判断是否为对象\nis_array()   //判断是否为数组\nis_null()    //判断是否为null\nis_file()    //判断是否为文件\nis_dir()    //判断是否为目录\nis_numeric()  //判断是否为数字\nis_nan()    //判断不是数字\nis_resource()  //判断是否为资源类型\nis_a($obj,$classname) //判断对象是否为类的实例可用 if($obj instanceof Classname）\n```\n#### 二、获取子串位置\n```\nstrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置。 \nstripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置, 不区分大小写。\nstrrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置。\nstrripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置,不区分大小写。 \n```\n#### 三、获取子串\n```\nsubstr($str,$start [,$length]); //获取子串\nsubstr_compare($main_str,$str,$offset[,$length]); //子串比较 从offset处开始比较\nsubstr_count($hs,$nd [,$offset=0 [,$length]]); //获取子串nd在hs中出现的次数\nsubstr_replace($string,$replacement,$start [,$length]); //字符串子串替换\n                //用$replacement替换掉$string从start开始长度为length的子串\nstrstr($hys,$nd [,bool $before_needle = false ]);//返回$nd在$hys 第一次出现的地方开始到字符串结束 为止的字符串\n        //第三个参数如果为true 则返回$nd 之前的字符串\nstristr($hys,$nd [,bool $before_needle = false ]); //同上，忽略大小写版本\nstrrchr($hys,$nd); //返回$nd在$hys最后一次出现的地方开始到字符串结束 为止的字符串\n        //一般和 substr(strrchr($hys,$nd),strlen($nd)); 合用\nstrpbrk($haystack,$char_list);//从$char_list中依次匹配单个字符在$haystack中第一次出现的地方\n            //到字符串结束的地方 的整个字符串\nstrtok($str,$token); //第一次使用 将字符串按分隔符$token进行分割\nstrtok($token);   //第二次使用\n    eg.\n    $string = \"This is\\tan example\\nstring\";\n    /* 使用制表符和换行符作为分界符 */\n    $tok = strtok($string, \" \\n\\t\");\n  \n    while ($tok !== false) {\n        echo \"Word=$tok<br />\";\n        $tok = strtok(\" \\n\\t\");\n    }\n```\n#### 字符串str_ 型函数\n```\nstr_getcsv($str); //将csv文件字符串转换成一个数组\nstr_replace($search,$replace,$subject [,&$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数\nstr_ireplace($search,$replace,$subject [,&$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数 忽略大小写\nstr_shuffle(string $str);//随机打乱字符串\nstr_split($str [,$len=1]);//将字符串转换成一个数组\n             //，每个数组单元的长度为$len\n```\n####五、字符串长度\n```\nstrlen($str); //字符串长度\n```\n#### 六、翻转字符串\n\n```\nstrrev(string $string);// 翻转字符串\n```\n#### 七、mb_类型字符串函数\nmb_类型字符串与上述字符串函数基本一样，\n只是加多一个可选的字符编码参数，用法同上\n这里列出一些其他有用函数\n```\n$encode = mb_detect_encoding($lines, array(\"ASCII\",\"UTF-8\",\"GB2312\",\"GBK\",\"BIG5\"));\nif($encode != \"UTF-8\"){\n  $lines = iconv($encode,\"UTF-8\", $lines);\n}\n```\n#### 八、字符串的相关操作\n1、转换字符串类型\n```\nstrval($str); //转换成字符串类型\nfloatval($str);//转换成浮点型\nintval($str); //转换成整型\n```\n2、大小写转换\n```\nstrtolower($str); //全部转换成小写\nstrtoupper($str); //全部转换成大写\n```\n3、字符串转时间戳\n```\nstrtotime($str); //时间格式的字符串转换成整型时间戳\n      //注意设置时区 否则会有 8小时误差\n```\n4、去除HTML 和 PHP 标记\n```\nstrip_tags($str [,$tags]);//去除不含$tags里标签外的所有标签\n```\n5、ascii转数字 数字转ascii\n```\nchr(int $ascii); //数字转换成ascii\nord(string $str); //返回$str第一个字符的ascii值\n```\n6、json的编码与解码\n```\njson_encode($obj/$arr/$str...);//编码成json 格式的字符串\njson_decode($jsonstr [,$assoc=true]); //解码成对象\n             //当$assoc=true 时 返回数组 而非对象\n```\n7、换行转<br/>\n```\nnl2br($str); //字符串 $str 所有新行之前插入\'<br/>\'\n```\n8、数组转字符串，字符串转数组\n```\nimplode($arr,$glue);//将一维数组转换为字符串\nexplode();//字符串转换为数组\n```\n9、千位分割格式化\n```\nstring number_format ( float $number [, int $decimals = 0 ] )\nstring number_format ( float $number , int $decimals = 0 , string $dec_point = \'.\' , string $thousands_sep = \',\' )\n @param  $number 你要格式化的数字 \n     $decimals 要保留的小数位数 \n     $dec_point 指定小数点显示的字符 \n     $thousands_sep 指定千位分隔符显示的字符 \n```\n10、去空格\n```\ntrim(string $str [,string $charlist ]); //去左右字符\nltrim(string $str [,string $charlist ]); //去左字符\nrtrim(string $str [,string $charlist ]); //去右字符\n```\n该函数删除 str 末端的空白字符并返回。\n\n不使用第二个参数， rtrim() 仅删除以下字符：\n• \" \" (ASCII 32 (0x20))，普通空白符。\n• \"\\t\" (ASCII 9 (0x09))，制表符。\n• \"\\n\" (ASCII 10 (0x0A))，换行符。\n• \"\\r\" (ASCII 13 (0x0D))，回车符。\n• \"\\0\" (ASCII 0 (0x00))，NUL 空字节符。\n• \"\\x0B\" (ASCII 11 (0x0B))，垂直制表符。\n过滤字符也可由 charlist 参数指定。一般要列出所有希望过滤的字符，\n也可以使用 \"..\" 列出一个字符范围\n11、转换字符串编码函数\n```\niconv($in_charset, $out_charset, $str);\n$in_charset输入字符集\n$out_charset输出字符集\n```\n12、字符串加密函数\n```\nsha1($str);\nmd5($str);\n```\n13、字符串转义与反转义函数\n```\naddcslashes(string $str , string $charlist);//转义字符串中的特殊字符\n        //eg. addcslashes($str,\"\\0..\\37!@\\177..\\377\");\n              //转义ascii 中0-37、177-377中不含@符号的字符\n  \nstripcslashes($str) — 反转义addcslashes()函数转义处理过的字符串\n 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，... 八进制以及十六进制的描述\n```\n14、按格式返回数据\n```\nsprintf — 按照要求对数据进行返回，但是不输出\n    可表示类型如下：\n    string s \n    integer d, u, c, o, x, X, b \n    double g, G, e, E, f, F \n    eg.\n    $num = 5;\n    $location = \'tree\';\n    $format = \'There are %d monkeys in the %s\';\n    echo sprintf($format, $num, $location);\n```', '0', null, '1569481036');
INSERT INTO `article` VALUES ('18', 'PHP常用的字符串函数', '1', '1', '<h4 id=\"h4--\"><a name=\"一、判断类型的函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、判断类型的函数</h4><pre><code>is_bool()    //判断是否为布尔型\nis_float()   //判断是否为浮点型\nis_real()    //同上\nis_int()    //判断是否为整型\nis_integer()  //同上\nis_string()   //判断是否为字符串\nis_object()   //判断是否为对象\nis_array()   //判断是否为数组\nis_null()    //判断是否为null\nis_file()    //判断是否为文件\nis_dir()    //判断是否为目录\nis_numeric()  //判断是否为数字\nis_nan()    //判断不是数字\nis_resource()  //判断是否为资源类型\nis_a($obj,$classname) //判断对象是否为类的实例可用 if($obj instanceof Classname）\n</code></pre><h4 id=\"h4--\"><a name=\"二、获取子串位置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、获取子串位置</h4><pre><code>strpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置。 \nstripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置, 不区分大小写。\nstrrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置。\nstrripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置,不区分大小写。\n</code></pre><h4 id=\"h4--\"><a name=\"三、获取子串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、获取子串</h4><pre><code>substr($str,$start [,$length]); //获取子串\nsubstr_compare($main_str,$str,$offset[,$length]); //子串比较 从offset处开始比较\nsubstr_count($hs,$nd [,$offset=0 [,$length]]); //获取子串nd在hs中出现的次数\nsubstr_replace($string,$replacement,$start [,$length]); //字符串子串替换\n                //用$replacement替换掉$string从start开始长度为length的子串\nstrstr($hys,$nd [,bool $before_needle = false ]);//返回$nd在$hys 第一次出现的地方开始到字符串结束 为止的字符串\n        //第三个参数如果为true 则返回$nd 之前的字符串\nstristr($hys,$nd [,bool $before_needle = false ]); //同上，忽略大小写版本\nstrrchr($hys,$nd); //返回$nd在$hys最后一次出现的地方开始到字符串结束 为止的字符串\n        //一般和 substr(strrchr($hys,$nd),strlen($nd)); 合用\nstrpbrk($haystack,$char_list);//从$char_list中依次匹配单个字符在$haystack中第一次出现的地方\n            //到字符串结束的地方 的整个字符串\nstrtok($str,$token); //第一次使用 将字符串按分隔符$token进行分割\nstrtok($token);   //第二次使用\n    eg.\n    $string = \"This is\\tan example\\nstring\";\n    /* 使用制表符和换行符作为分界符 */\n    $tok = strtok($string, \" \\n\\t\");\n\n    while ($tok !== false) {\n        echo \"Word=$tok&lt;br&gt;\";\n        $tok = strtok(\" \\n\\t\");\n    }\n</code></pre><h4 id=\"h4--str_-\"><a name=\"四、字符串str_ 型函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、字符串str_ 型函数</h4><pre><code>str_getcsv($str); //将csv文件字符串转换成一个数组\nstr_replace($search,$replace,$subject [,&amp;amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数\nstr_ireplace($search,$replace,$subject [,&amp;amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数 忽略大小写\nstr_shuffle(string $str);//随机打乱字符串\nstr_split($str [,$len=1]);//将字符串转换成一个数组\n             //，每个数组单元的长度为$len\n</code></pre><h4 id=\"h4--\"><a name=\"五、字符串长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、字符串长度</h4><pre><code>strlen($str); //字符串长度\n</code></pre><h4 id=\"h4--\"><a name=\"六、翻转字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、翻转字符串</h4><pre><code>strrev(string $string);// 翻转字符串\n</code></pre><h4 id=\"h4--mb_-\"><a name=\"七、mb_类型字符串函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、mb_类型字符串函数</h4><p>mb_类型字符串与上述字符串函数基本一样，<br>只是加多一个可选的字符编码参数，用法同上<br>这里列出一些其他有用函数\n<pre><code>$encode = mb_detect_encoding($lines, array(\"ASCII\",\"UTF-8\",\"GB2312\",\"GBK\",\"BIG5\"));\nif($encode != \"UTF-8\"){\n  $lines = iconv($encode,\"UTF-8\", $lines);\n}\n</code></pre><h4 id=\"h4--\"><a name=\"八、字符串的相关操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、字符串的相关操作</h4><p>1、转换字符串类型</p>\n<pre><code>strval($str); //转换成字符串类型\nfloatval($str);//转换成浮点型\nintval($str); //转换成整型\n</code></pre><p>2、大小写转换</p>\n<pre><code>strtolower($str); //全部转换成小写\nstrtoupper($str); //全部转换成大写\n</code></pre><p>3、字符串转时间戳</p>\n<pre><code>strtotime($str); //时间格式的字符串转换成整型时间戳\n      //注意设置时区 否则会有 8小时误差\n</code></pre><p>4、去除HTML 和 PHP 标记</p>\n<pre><code>strip_tags($str [,$tags]);//去除不含$tags里标签外的所有标签\n</code></pre><p>5、ascii转数字 数字转ascii</p>\n<pre><code>chr(int $ascii); //数字转换成ascii\nord(string $str); //返回$str第一个字符的ascii值\n</code></pre><p>6、json的编码与解码</p>\n<pre><code>json_encode($obj/$arr/$str...);//编码成json 格式的字符串\njson_decode($jsonstr [,$assoc=true]); //解码成对象\n             //当$assoc=true 时 返回数组 而非对象\n</code></pre><p>7、换行转<br>\n<pre><code>nl2br($str); //字符串 $str 所有新行之前插入\'&lt;br&gt;\'\n</code></pre><p>8、数组转字符串，字符串转数组</p>\n<pre><code>implode($arr,$glue);//将一维数组转换为字符串\nexplode();//字符串转换为数组\n</code></pre><p>9、千位分割格式化</p>\n<pre><code>string number_format ( float $number [, int $decimals = 0 ] )\nstring number_format ( float $number , int $decimals = 0 , string $dec_point = \'.\' , string $thousands_sep = \',\' )\n @param  $number 你要格式化的数字 \n     $decimals 要保留的小数位数 \n     $dec_point 指定小数点显示的字符 \n     $thousands_sep 指定千位分隔符显示的字符\n</code></pre><p>10、去空格</p>\n<pre><code>trim(string $str [,string $charlist ]); //去左右字符\nltrim(string $str [,string $charlist ]); //去左字符\nrtrim(string $str [,string $charlist ]); //去右字符\n</code></pre><p>该函数删除 str 末端的空白字符并返回。</p>\n<p>不使用第二个参数， rtrim() 仅删除以下字符：<br>• “ “ (ASCII 32 (0x20))，普通空白符。<br>• “\\t” (ASCII 9 (0x09))，制表符。<br>• “\\n” (ASCII 10 (0x0A))，换行符。<br>• “\\r” (ASCII 13 (0x0D))，回车符。<br>• “\\0” (ASCII 0 (0x00))，NUL 空字节符。<br>• “\\x0B” (ASCII 11 (0x0B))，垂直制表符。<br>过滤字符也可由 charlist 参数指定。一般要列出所有希望过滤的字符，<br>也可以使用 “..” 列出一个字符范围<br>11、转换字符串编码函数\n<pre><code>iconv($in_charset, $out_charset, $str);\n$in_charset输入字符集\n$out_charset输出字符集\n</code></pre><p>12、字符串加密函数</p>\n<pre><code>sha1($str);\nmd5($str);\n</code></pre><p>13、字符串转义与反转义函数</p>\n<pre><code>addcslashes(string $str , string $charlist);//转义字符串中的特殊字符\n        //eg. addcslashes($str,\"\\0..\\37!@\\177..\\377\");\n              //转义ascii 中0-37、177-377中不含@符号的字符\n\nstripcslashes($str) — 反转义addcslashes()函数转义处理过的字符串\n 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，... 八进制以及十六进制的描述\n</code></pre><p>14、按格式返回数据</p>\n<pre><code>sprintf — 按照要求对数据进行返回，但是不输出\n    可表示类型如下：\n    string s \n    integer d, u, c, o, x, X, b \n    double g, G, e, E, f, F \n    eg.\n    $num = 5;\n    $location = \'tree\';\n    $format = \'There are %d monkeys in the %s\';\n    echo sprintf($format, $num, $location);\n</code></pre>', '#### 一、判断类型的函数\n```\nis_bool()    //判断是否为布尔型\nis_float()   //判断是否为浮点型\nis_real()    //同上\nis_int()    //判断是否为整型\nis_integer()  //同上\nis_string()   //判断是否为字符串\nis_object()   //判断是否为对象\nis_array()   //判断是否为数组\nis_null()    //判断是否为null\nis_file()    //判断是否为文件\nis_dir()    //判断是否为目录\nis_numeric()  //判断是否为数字\nis_nan()    //判断不是数字\nis_resource()  //判断是否为资源类型\nis_a($obj,$classname) //判断对象是否为类的实例可用 if($obj instanceof Classname）\n```\n#### 二、获取子串位置\n```\nstrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置。 \nstripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中首次出现的数字位置, 不区分大小写。\nstrrpos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置。\nstrripos($hs,$nd [,int $offset = 0 ]) //返回nd 在 hs 中最后一次出现的数字位置,不区分大小写。 \n```\n#### 三、获取子串\n```\nsubstr($str,$start [,$length]); //获取子串\nsubstr_compare($main_str,$str,$offset[,$length]); //子串比较 从offset处开始比较\nsubstr_count($hs,$nd [,$offset=0 [,$length]]); //获取子串nd在hs中出现的次数\nsubstr_replace($string,$replacement,$start [,$length]); //字符串子串替换\n                //用$replacement替换掉$string从start开始长度为length的子串\nstrstr($hys,$nd [,bool $before_needle = false ]);//返回$nd在$hys 第一次出现的地方开始到字符串结束 为止的字符串\n        //第三个参数如果为true 则返回$nd 之前的字符串\nstristr($hys,$nd [,bool $before_needle = false ]); //同上，忽略大小写版本\nstrrchr($hys,$nd); //返回$nd在$hys最后一次出现的地方开始到字符串结束 为止的字符串\n        //一般和 substr(strrchr($hys,$nd),strlen($nd)); 合用\nstrpbrk($haystack,$char_list);//从$char_list中依次匹配单个字符在$haystack中第一次出现的地方\n            //到字符串结束的地方 的整个字符串\nstrtok($str,$token); //第一次使用 将字符串按分隔符$token进行分割\nstrtok($token);   //第二次使用\n    eg.\n    $string = \"This is\\tan example\\nstring\";\n    /* 使用制表符和换行符作为分界符 */\n    $tok = strtok($string, \" \\n\\t\");\n  \n    while ($tok !== false) {\n        echo \"Word=$tok<br>\";\n        $tok = strtok(\" \\n\\t\");\n    }\n```\n#### 四、字符串str_ 型函数\n```\nstr_getcsv($str); //将csv文件字符串转换成一个数组\nstr_replace($search,$replace,$subject [,&amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数\nstr_ireplace($search,$replace,$subject [,&amp;$count]);//搜索并替换字符串\n      //第四个参数被指定的话，将会赋值给他替换的次数 忽略大小写\nstr_shuffle(string $str);//随机打乱字符串\nstr_split($str [,$len=1]);//将字符串转换成一个数组\n             //，每个数组单元的长度为$len\n```\n####五、字符串长度\n```\nstrlen($str); //字符串长度\n```\n#### 六、翻转字符串\n\n```\nstrrev(string $string);// 翻转字符串\n```\n#### 七、mb_类型字符串函数\nmb_类型字符串与上述字符串函数基本一样，\n只是加多一个可选的字符编码参数，用法同上\n这里列出一些其他有用函数\n```\n$encode = mb_detect_encoding($lines, array(\"ASCII\",\"UTF-8\",\"GB2312\",\"GBK\",\"BIG5\"));\nif($encode != \"UTF-8\"){\n  $lines = iconv($encode,\"UTF-8\", $lines);\n}\n```\n#### 八、字符串的相关操作\n1、转换字符串类型\n```\nstrval($str); //转换成字符串类型\nfloatval($str);//转换成浮点型\nintval($str); //转换成整型\n```\n2、大小写转换\n```\nstrtolower($str); //全部转换成小写\nstrtoupper($str); //全部转换成大写\n```\n3、字符串转时间戳\n```\nstrtotime($str); //时间格式的字符串转换成整型时间戳\n      //注意设置时区 否则会有 8小时误差\n```\n4、去除HTML 和 PHP 标记\n```\nstrip_tags($str [,$tags]);//去除不含$tags里标签外的所有标签\n```\n5、ascii转数字 数字转ascii\n```\nchr(int $ascii); //数字转换成ascii\nord(string $str); //返回$str第一个字符的ascii值\n```\n6、json的编码与解码\n```\njson_encode($obj/$arr/$str...);//编码成json 格式的字符串\njson_decode($jsonstr [,$assoc=true]); //解码成对象\n             //当$assoc=true 时 返回数组 而非对象\n```\n7、换行转<br>\n```\nnl2br($str); //字符串 $str 所有新行之前插入\'<br>\'\n```\n8、数组转字符串，字符串转数组\n```\nimplode($arr,$glue);//将一维数组转换为字符串\nexplode();//字符串转换为数组\n```\n9、千位分割格式化\n```\nstring number_format ( float $number [, int $decimals = 0 ] )\nstring number_format ( float $number , int $decimals = 0 , string $dec_point = \'.\' , string $thousands_sep = \',\' )\n @param  $number 你要格式化的数字 \n     $decimals 要保留的小数位数 \n     $dec_point 指定小数点显示的字符 \n     $thousands_sep 指定千位分隔符显示的字符 \n```\n10、去空格\n```\ntrim(string $str [,string $charlist ]); //去左右字符\nltrim(string $str [,string $charlist ]); //去左字符\nrtrim(string $str [,string $charlist ]); //去右字符\n```\n该函数删除 str 末端的空白字符并返回。\n\n不使用第二个参数， rtrim() 仅删除以下字符：\n• \" \" (ASCII 32 (0x20))，普通空白符。\n• \"\\t\" (ASCII 9 (0x09))，制表符。\n• \"\\n\" (ASCII 10 (0x0A))，换行符。\n• \"\\r\" (ASCII 13 (0x0D))，回车符。\n• \"\\0\" (ASCII 0 (0x00))，NUL 空字节符。\n• \"\\x0B\" (ASCII 11 (0x0B))，垂直制表符。\n过滤字符也可由 charlist 参数指定。一般要列出所有希望过滤的字符，\n也可以使用 \"..\" 列出一个字符范围\n11、转换字符串编码函数\n```\niconv($in_charset, $out_charset, $str);\n$in_charset输入字符集\n$out_charset输出字符集\n```\n12、字符串加密函数\n```\nsha1($str);\nmd5($str);\n```\n13、字符串转义与反转义函数\n```\naddcslashes(string $str , string $charlist);//转义字符串中的特殊字符\n        //eg. addcslashes($str,\"\\0..\\37!@\\177..\\377\");\n              //转义ascii 中0-37、177-377中不含@符号的字符\n  \nstripcslashes($str) — 反转义addcslashes()函数转义处理过的字符串\n 返回反转义后的字符串。可识别类似 C 语言的 \\n，\\r，... 八进制以及十六进制的描述\n```\n14、按格式返回数据\n```\nsprintf — 按照要求对数据进行返回，但是不输出\n    可表示类型如下：\n    string s \n    integer d, u, c, o, x, X, b \n    double g, G, e, E, f, F \n    eg.\n    $num = 5;\n    $location = \'tree\';\n    $format = \'There are %d monkeys in the %s\';\n    echo sprintf($format, $num, $location);\n```', '1', '1569481843', '1569481043');
INSERT INTO `article` VALUES ('19', 'PHP常用数组函数', '1', '1', '<p>1.可用于队列操作</p>\n<pre><code>array_push($arr, $value1, ...)将一个或多个单元压入数组的末尾（入栈）\narray_pop($arr);弹出数组最后一个单元（出栈）\narray_unshift($arr, $value1, ...);在数组开头插入一个或多个单元\narray_shift($arr);将数组开头的单元移出数组\n</code></pre><p>2.数组自定义操作</p>\n<pre><code>array_map()\n\n语法：array array_map ( callable $callback , array $array1 [, array $... ] )\n说明：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。\n详细使用\n例：\n  &lt;?php\nfunction cube($n)\n{\n    return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n输出：\nArray\n(\n    [0] =&gt; 1\n    [1] =&gt; 8\n    [2] =&gt; 27\n    [3] =&gt; 64\n    [4] =&gt; 125\n)\narray_walk()\n语法：bool array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] )\n说明：使用用户自定义函数对数组中的每个元素做回调处理，不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。\n具体使用\n例：\n$fruits = array(\"d\" =&gt; \"lemon\", \"a\" =&gt; \"orange\", \"b\" =&gt; \"banana\", \"c\" =&gt; \"apple\");\n\nfunction test_alter(&amp;$item1, $key, $prefix) {\n    $item1 = \"$prefix: $item1\";\n}\n\nfunction test_print($item2, $key) {\n    echo \"$key. $item2&lt;br /&gt;\\n\";\n}\n\necho \"Before ...:\\n\";\narray_walk($fruits, \'test_print\');\n\narray_walk($fruits, \'test_alter\', \'fruit\');\necho \"... and after:\\n\";\n\narray_walk($fruits, \'test_print\');\n\n结果：\nBefore ...:\nd. lemon\na. orange\nb. banana\nc. apple\n... and after:\nd. fruit: lemon\na. fruit: orange\nb. fruit: banana\nc. fruit: apple\n例：\n$origin = [\n    [\'status\' =&gt; \'error\', \'num\' =&gt; 5],\n    [\'status\' =&gt; \'success\', \'num\' =&gt; 3]\n];\n$statistics = [];\n array_walk($origin, function ($value) use (&amp;$statistics) {\n    return $statistics[$value[\'status\']] = $value[\'num\'];\n});\n//statistics = [\n    //\'error\' =&gt; 5,\n    //\'success\' =&gt; 3\n//];\narray_reduce()\n语法：mixed array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] )\n说明：用回调函数迭代地将数组简化为单一的值，\n具体使用\n参数：\ncallback\nmixed callback ( mixed $carry , mixed $item )\ncarry\n携带上次迭代里的值； 如果本次迭代是第一次，那么这个值是 initial。\n\nitem\n携带了本次迭代的值。\n\ninitial\n如果指定了可选参数 initial，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。\n例：\n  &lt;?php\nfunction sum($carry, $item)\n{\n    $carry += $item;\n    return $carry;\n}\n\nfunction product($carry, $item)\n{\n    $carry *= $item;\n    return $carry;\n}\n\n$a = array(1, 2, 3, 4, 5);\n$x = array();\n\nvar_dump(array_reduce($a, \"sum\")); // int(15)\nvar_dump(array_reduce($a, \"product\", 10)); // int(1200), because: 10*1*2*3*4*5\nvar_dump(array_reduce($x, \"sum\", \"No data to reduce\")); // string(17) \"No data to reduce\"\n</code></pre><p>3.多数组操作</p>\n<pre><code>array_merge($array1, $array2, ...)合并一个或多个数组\narray_diff($array1, $array2, ...) 计算数组的差集； 对比 array1 和其他一个或者多个数字，返回在 array1 中但是不在其他 array 里的值。\narray_intersect($array1, $array2, ...)计算数组的交集；返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。\n</code></pre><p>4.其他</p>\n<pre><code>array_keys 返回数组中部分的或所有的键名\narray_values 返回数组中所有的值\narray_unique 移除数组中重复的值\narray_multisort 对多个数组或多维数组进行排序\narray_reverse 返回单元顺序相反的数组\narray_slice 从数组中取出一段\n语法：array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )\narray_search 在数组中搜索给定的值，如果成功则返回首个相应的键名\n语法：mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] )\n</code></pre>', '1.可用于队列操作\n```\narray_push($arr, $value1, ...)将一个或多个单元压入数组的末尾（入栈）\narray_pop($arr);弹出数组最后一个单元（出栈）\narray_unshift($arr, $value1, ...);在数组开头插入一个或多个单元\narray_shift($arr);将数组开头的单元移出数组\n```\n\n2.数组自定义操作\n```\narray_map()\n\n语法：array array_map ( callable $callback , array $array1 [, array $... ] )\n说明：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。\n详细使用\n例：\n  <?php\nfunction cube($n)\n{\n    return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n输出：\nArray\n(\n    [0] => 1\n    [1] => 8\n    [2] => 27\n    [3] => 64\n    [4] => 125\n)\narray_walk()\n语法：bool array_walk ( array &$array , callable $callback [, mixed $userdata = NULL ] )\n说明：使用用户自定义函数对数组中的每个元素做回调处理，不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。\n具体使用\n例：\n$fruits = array(\"d\" => \"lemon\", \"a\" => \"orange\", \"b\" => \"banana\", \"c\" => \"apple\");\n\nfunction test_alter(&$item1, $key, $prefix) {\n    $item1 = \"$prefix: $item1\";\n}\n\nfunction test_print($item2, $key) {\n    echo \"$key. $item2<br />\\n\";\n}\n\necho \"Before ...:\\n\";\narray_walk($fruits, \'test_print\');\n\narray_walk($fruits, \'test_alter\', \'fruit\');\necho \"... and after:\\n\";\n\narray_walk($fruits, \'test_print\');\n\n结果：\nBefore ...:\nd. lemon\na. orange\nb. banana\nc. apple\n... and after:\nd. fruit: lemon\na. fruit: orange\nb. fruit: banana\nc. fruit: apple\n例：\n$origin = [\n	[\'status\' => \'error\', \'num\' => 5],\n	[\'status\' => \'success\', \'num\' => 3]\n];\n$statistics = [];\n array_walk($origin, function ($value) use (&$statistics) {\n    return $statistics[$value[\'status\']] = $value[\'num\'];\n});\n//statistics = [\n    //\'error\' => 5,\n    //\'success\' => 3\n//];\narray_reduce()\n语法：mixed array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] )\n说明：用回调函数迭代地将数组简化为单一的值，\n具体使用\n参数：\ncallback\nmixed callback ( mixed $carry , mixed $item )\ncarry\n携带上次迭代里的值； 如果本次迭代是第一次，那么这个值是 initial。\n\nitem\n携带了本次迭代的值。\n\ninitial\n如果指定了可选参数 initial，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。\n例：\n  <?php\nfunction sum($carry, $item)\n{\n    $carry += $item;\n    return $carry;\n}\n\nfunction product($carry, $item)\n{\n    $carry *= $item;\n    return $carry;\n}\n\n$a = array(1, 2, 3, 4, 5);\n$x = array();\n\nvar_dump(array_reduce($a, \"sum\")); // int(15)\nvar_dump(array_reduce($a, \"product\", 10)); // int(1200), because: 10*1*2*3*4*5\nvar_dump(array_reduce($x, \"sum\", \"No data to reduce\")); // string(17) \"No data to reduce\"\n```\n3.多数组操作\n```\narray_merge($array1, $array2, ...)合并一个或多个数组\narray_diff($array1, $array2, ...) 计算数组的差集； 对比 array1 和其他一个或者多个数字，返回在 array1 中但是不在其他 array 里的值。\narray_intersect($array1, $array2, ...)计算数组的交集；返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。\n```\n4.其他\n```\narray_keys 返回数组中部分的或所有的键名\narray_values 返回数组中所有的值\narray_unique 移除数组中重复的值\narray_multisort 对多个数组或多维数组进行排序\narray_reverse 返回单元顺序相反的数组\narray_slice 从数组中取出一段\n语法：array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )\narray_search 在数组中搜索给定的值，如果成功则返回首个相应的键名\n语法：mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] )\n```', '0', null, '1569482315');
INSERT INTO `article` VALUES ('20', 'test', '1', '0', '<p>test</p>\n', 'test', '0', null, '1569482536');
INSERT INTO `article` VALUES ('21', 'test', '1', '0', '<p>test</p>\n', 'test', '0', null, '1569482538');
INSERT INTO `article` VALUES ('22', 'test', '1', '0', '<p>test</p>\n', 'test', '0', null, '1569482541');
INSERT INTO `article` VALUES ('23', 'test', '1', '0', '<p>t</p>\n', 't', '0', null, '1569482688');
INSERT INTO `article` VALUES ('24', 'PHP常用数组函数', '1', '1', '<p><p>1.可用于队列操作</p></p>\n<pre><code>array_push($arr, $value1, ...)将一个或多个单元压入数组的末尾（入栈）\narray_pop($arr);弹出数组最后一个单元（出栈）\narray_unshift($arr, $value1, ...);在数组开头插入一个或多个单元\narray_shift($arr);将数组开头的单元移出数组\n</code></pre><p>2.数组自定义操作</p>\n<pre><code>array_map()\n\n语法：array array_map ( callable $callback , array $array1 [, array $... ] )\n说明：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。\n详细使用\n例：\n  &lt;?php\nfunction cube($n)\n{\n    return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n输出：\nArray\n(\n    [0] =&gt; 1\n    [1] =&gt; 8\n    [2] =&gt; 27\n    [3] =&gt; 64\n    [4] =&gt; 125\n)\narray_walk()\n语法：bool array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] )\n说明：使用用户自定义函数对数组中的每个元素做回调处理，不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。\n具体使用\n例：\n$fruits = array(\"d\" =&gt; \"lemon\", \"a\" =&gt; \"orange\", \"b\" =&gt; \"banana\", \"c\" =&gt; \"apple\");\n\nfunction test_alter(&amp;$item1, $key, $prefix) {\n    $item1 = \"$prefix: $item1\";\n}\n\nfunction test_print($item2, $key) {\n    echo \"$key. $item2&lt;br /&gt;\\n\";\n}\n\necho \"Before ...:\\n\";\narray_walk($fruits, \'test_print\');\n\narray_walk($fruits, \'test_alter\', \'fruit\');\necho \"... and after:\\n\";\n\narray_walk($fruits, \'test_print\');\n\n结果：\nBefore ...:\nd. lemon\na. orange\nb. banana\nc. apple\n... and after:\nd. fruit: lemon\na. fruit: orange\nb. fruit: banana\nc. fruit: apple\n例：\n$origin = [\n    [\'status\' =&gt; \'error\', \'num\' =&gt; 5],\n    [\'status\' =&gt; \'success\', \'num\' =&gt; 3]\n];\n$statistics = [];\n array_walk($origin, function ($value) use (&amp;$statistics) {\n    return $statistics[$value[\'status\']] = $value[\'num\'];\n});\n//statistics = [\n    //\'error\' =&gt; 5,\n    //\'success\' =&gt; 3\n//];\narray_reduce()\n语法：mixed array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] )\n说明：用回调函数迭代地将数组简化为单一的值，\n具体使用\n参数：\ncallback\nmixed callback ( mixed $carry , mixed $item )\ncarry\n携带上次迭代里的值； 如果本次迭代是第一次，那么这个值是 initial。\n\nitem\n携带了本次迭代的值。\n\ninitial\n如果指定了可选参数 initial，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。\n例：\n  &lt;?php\nfunction sum($carry, $item)\n{\n    $carry += $item;\n    return $carry;\n}\n\nfunction product($carry, $item)\n{\n    $carry *= $item;\n    return $carry;\n}\n\n$a = array(1, 2, 3, 4, 5);\n$x = array();\n\nvar_dump(array_reduce($a, \"sum\")); // int(15)\nvar_dump(array_reduce($a, \"product\", 10)); // int(1200), because: 10*1*2*3*4*5\nvar_dump(array_reduce($x, \"sum\", \"No data to reduce\")); // string(17) \"No data to reduce\"\n</code></pre><p>3.多数组操作</p>\n<pre><code>array_merge($array1, $array2, ...)合并一个或多个数组\narray_diff($array1, $array2, ...) 计算数组的差集； 对比 array1 和其他一个或者多个数字，返回在 array1 中但是不在其他 array 里的值。\narray_intersect($array1, $array2, ...)计算数组的交集；返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。\n</code></pre><p>4.其他</p>\n<pre><code>array_keys 返回数组中部分的或所有的键名\narray_values 返回数组中所有的值\narray_unique 移除数组中重复的值\narray_multisort 对多个数组或多维数组进行排序\narray_reverse 返回单元顺序相反的数组\narray_slice 从数组中取出一段\n语法：array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )\narray_search 在数组中搜索给定的值，如果成功则返回首个相应的键名\n语法：mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] )\n</code></pre>', '<p>1.可用于队列操作</p>\n<pre><code>array_push($arr, $value1, ...)将一个或多个单元压入数组的末尾（入栈）\narray_pop($arr);弹出数组最后一个单元（出栈）\narray_unshift($arr, $value1, ...);在数组开头插入一个或多个单元\narray_shift($arr);将数组开头的单元移出数组\n</code></pre><p>2.数组自定义操作</p>\n<pre><code>array_map()\n\n语法：array array_map ( callable $callback , array $array1 [, array $... ] )\n说明：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。\n详细使用\n例：\n  &lt;?php\nfunction cube($n)\n{\n    return($n * $n * $n);\n}\n\n$a = array(1, 2, 3, 4, 5);\n$b = array_map(\"cube\", $a);\nprint_r($b);\n输出：\nArray\n(\n    [0] =&gt; 1\n    [1] =&gt; 8\n    [2] =&gt; 27\n    [3] =&gt; 64\n    [4] =&gt; 125\n)\narray_walk()\n语法：bool array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] )\n说明：使用用户自定义函数对数组中的每个元素做回调处理，不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。\n具体使用\n例：\n$fruits = array(\"d\" =&gt; \"lemon\", \"a\" =&gt; \"orange\", \"b\" =&gt; \"banana\", \"c\" =&gt; \"apple\");\n\nfunction test_alter(&amp;$item1, $key, $prefix) {\n    $item1 = \"$prefix: $item1\";\n}\n\nfunction test_print($item2, $key) {\n    echo \"$key. $item2&lt;br /&gt;\\n\";\n}\n\necho \"Before ...:\\n\";\narray_walk($fruits, \'test_print\');\n\narray_walk($fruits, \'test_alter\', \'fruit\');\necho \"... and after:\\n\";\n\narray_walk($fruits, \'test_print\');\n\n结果：\nBefore ...:\nd. lemon\na. orange\nb. banana\nc. apple\n... and after:\nd. fruit: lemon\na. fruit: orange\nb. fruit: banana\nc. fruit: apple\n例：\n$origin = [\n    [\'status\' =&gt; \'error\', \'num\' =&gt; 5],\n    [\'status\' =&gt; \'success\', \'num\' =&gt; 3]\n];\n$statistics = [];\n array_walk($origin, function ($value) use (&amp;$statistics) {\n    return $statistics[$value[\'status\']] = $value[\'num\'];\n});\n//statistics = [\n    //\'error\' =&gt; 5,\n    //\'success\' =&gt; 3\n//];\narray_reduce()\n语法：mixed array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] )\n说明：用回调函数迭代地将数组简化为单一的值，\n具体使用\n参数：\ncallback\nmixed callback ( mixed $carry , mixed $item )\ncarry\n携带上次迭代里的值； 如果本次迭代是第一次，那么这个值是 initial。\n\nitem\n携带了本次迭代的值。\n\ninitial\n如果指定了可选参数 initial，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。\n例：\n  &lt;?php\nfunction sum($carry, $item)\n{\n    $carry += $item;\n    return $carry;\n}\n\nfunction product($carry, $item)\n{\n    $carry *= $item;\n    return $carry;\n}\n\n$a = array(1, 2, 3, 4, 5);\n$x = array();\n\nvar_dump(array_reduce($a, \"sum\")); // int(15)\nvar_dump(array_reduce($a, \"product\", 10)); // int(1200), because: 10*1*2*3*4*5\nvar_dump(array_reduce($x, \"sum\", \"No data to reduce\")); // string(17) \"No data to reduce\"\n</code></pre><p>3.多数组操作</p>\n<pre><code>array_merge($array1, $array2, ...)合并一个或多个数组\narray_diff($array1, $array2, ...) 计算数组的差集； 对比 array1 和其他一个或者多个数字，返回在 array1 中但是不在其他 array 里的值。\narray_intersect($array1, $array2, ...)计算数组的交集；返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。\n</code></pre><p>4.其他</p>\n<pre><code>array_keys 返回数组中部分的或所有的键名\narray_values 返回数组中所有的值\narray_unique 移除数组中重复的值\narray_multisort 对多个数组或多维数组进行排序\narray_reverse 返回单元顺序相反的数组\narray_slice 从数组中取出一段\n语法：array array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] )\narray_search 在数组中搜索给定的值，如果成功则返回首个相应的键名\n语法：mixed array_search ( mixed $needle , array $haystack [, bool $strict = false ] )\n</code></pre>', '1', '1569482775', '1569482744');
INSERT INTO `article` VALUES ('25', 'test', '1', '0', '<p>tt</p>\n', 'tt', '0', null, '1569482829');
INSERT INTO `article` VALUES ('26', 'PHP判断{函数/类/方法/属性}是否存在', '1', '1', '<p>1.php判断系统函数或自己写的函数是否存在</p>\n<pre><code>bool function_exists ( string $function_name ) 判断函数是否已经定义，例如：\n\nif(function_exists(\'curl_init\')){\n    curl_init();\n}else{\n    echo \'not function curl_init\';\n}\n</code></pre><p>2.php判断类是否存在</p>\n<pre><code>bool class_exists ( string $class_name [, bool $autoload = true ] ) 检查一个类是否已经定义，一定以返回true，否则返回false，例如：\n\nif(class_exists(\'MySQL\')){\n    $myclass=new MySQL();\n}\n</code></pre><p>3.php判断类里面的某个方法是否已经定义</p>\n<pre><code>bool method_exists ( mixed $object , string $method_name ) 检查类的方法是否存在，例如：\n\n$directory=new Directory;\nif(!method_exists($directory,\'read\')){\n    echo \'未定义read方法！\';\n}\n</code></pre><p>4.php 判断类里面的某个属性是否已经定义</p>\n<pre><code>bool property_exists ( mixed $class , string $property )检查类的属性是否存在，例如：\n\n$directory=new Directory;\nif(!property_exists($directory,\'li\')){\n    echo \'未定义li属性！\';\n</code></pre>', '1.php判断系统函数或自己写的函数是否存在\n```\nbool function_exists ( string $function_name ) 判断函数是否已经定义，例如：\n\nif(function_exists(\'curl_init\')){\n    curl_init();\n}else{\n    echo \'not function curl_init\';\n}\n```\n2.php判断类是否存在\n```\nbool class_exists ( string $class_name [, bool $autoload = true ] ) 检查一个类是否已经定义，一定以返回true，否则返回false，例如：\n\nif(class_exists(\'MySQL\')){\n    $myclass=new MySQL();\n}\n```\n3.php判断类里面的某个方法是否已经定义\n```\nbool method_exists ( mixed $object , string $method_name ) 检查类的方法是否存在，例如：\n\n$directory=new Directory;\nif(!method_exists($directory,\'read\')){\n    echo \'未定义read方法！\';\n}\n```\n4.php 判断类里面的某个属性是否已经定义\n```\nbool property_exists ( mixed $class , string $property )检查类的属性是否存在，例如：\n\n$directory=new Directory;\nif(!property_exists($directory,\'li\')){\n    echo \'未定义li属性！\';\n```', '0', null, '1569482998');
INSERT INTO `article` VALUES ('27', 'PHP判断{函数/类/方法/属性}是否存在', '1', '1', '<p>1.php判断系统函数或自己写的函数是否存在</p>\n<pre><code>bool function_exists ( string $function_name ) 判断函数是否已经定义，例如：\n\nif(function_exists(\'curl_init\')){\n    curl_init();\n}else{\n    echo \'not function curl_init\';\n}\n</code></pre><p>2.php判断类是否存在</p>\n<pre><code>bool class_exists ( string $class_name [, bool $autoload = true ] ) 检查一个类是否已经定义，一定以返回true，否则返回false，例如：\n\nif(class_exists(\'MySQL\')){\n    $myclass=new MySQL();\n}\n</code></pre><p>3.php判断类里面的某个方法是否已经定义</p>\n<pre><code>bool method_exists ( mixed $object , string $method_name ) 检查类的方法是否存在，例如：\n\n$directory=new Directory;\nif(!method_exists($directory,\'read\')){\n    echo \'未定义read方法！\';\n}\n</code></pre><p>4.php 判断类里面的某个属性是否已经定义</p>\n<pre><code>bool property_exists ( mixed $class , string $property )检查类的属性是否存在，例如：\n\n$directory=new Directory;\nif(!property_exists($directory,\'li\')){\n    echo \'未定义li属性！\';\n</code></pre>', '1.php判断系统函数或自己写的函数是否存在\n```\nbool function_exists ( string $function_name ) 判断函数是否已经定义，例如：\n\nif(function_exists(\'curl_init\')){\n    curl_init();\n}else{\n    echo \'not function curl_init\';\n}\n```\n2.php判断类是否存在\n```\nbool class_exists ( string $class_name [, bool $autoload = true ] ) 检查一个类是否已经定义，一定以返回true，否则返回false，例如：\n\nif(class_exists(\'MySQL\')){\n    $myclass=new MySQL();\n}\n```\n3.php判断类里面的某个方法是否已经定义\n```\nbool method_exists ( mixed $object , string $method_name ) 检查类的方法是否存在，例如：\n\n$directory=new Directory;\nif(!method_exists($directory,\'read\')){\n    echo \'未定义read方法！\';\n}\n```\n4.php 判断类里面的某个属性是否已经定义\n```\nbool property_exists ( mixed $class , string $property )检查类的属性是否存在，例如：\n\n$directory=new Directory;\nif(!property_exists($directory,\'li\')){\n    echo \'未定义li属性！\';\n```', '0', null, '1569483002');
INSERT INTO `article` VALUES ('28', 'PHP判断{函数/类/方法/属性}是否存在', '1', '1', '<p>1.php判断系统函数或自己写的函数是否存在</p>\n<pre><code>bool function_exists ( string $function_name ) 判断函数是否已经定义，例如：\n\nif(function_exists(\'curl_init\')){\n    curl_init();\n}else{\n    echo \'not function curl_init\';\n}\n</code></pre><p>2.php判断类是否存在</p>\n<pre><code>bool class_exists ( string $class_name [, bool $autoload = true ] ) 检查一个类是否已经定义，一定以返回true，否则返回false，例如：\n\nif(class_exists(\'MySQL\')){\n    $myclass=new MySQL();\n}\n</code></pre><p>3.php判断类里面的某个方法是否已经定义</p>\n<pre><code>bool method_exists ( mixed $object , string $method_name ) 检查类的方法是否存在，例如：\n\n$directory=new Directory;\nif(!method_exists($directory,\'read\')){\n    echo \'未定义read方法！\';\n}\n</code></pre><p>4.php 判断类里面的某个属性是否已经定义</p>\n<pre><code>bool property_exists ( mixed $class , string $property )检查类的属性是否存在，例如：\n\n$directory=new Directory;\nif(!property_exists($directory,\'li\')){\n    echo \'未定义li属性！\';\n</code></pre>', '1.php判断系统函数或自己写的函数是否存在\n```\nbool function_exists ( string $function_name ) 判断函数是否已经定义，例如：\n\nif(function_exists(\'curl_init\')){\n    curl_init();\n}else{\n    echo \'not function curl_init\';\n}\n```\n2.php判断类是否存在\n```\nbool class_exists ( string $class_name [, bool $autoload = true ] ) 检查一个类是否已经定义，一定以返回true，否则返回false，例如：\n\nif(class_exists(\'MySQL\')){\n    $myclass=new MySQL();\n}\n```\n3.php判断类里面的某个方法是否已经定义\n```\nbool method_exists ( mixed $object , string $method_name ) 检查类的方法是否存在，例如：\n\n$directory=new Directory;\nif(!method_exists($directory,\'read\')){\n    echo \'未定义read方法！\';\n}\n```\n4.php 判断类里面的某个属性是否已经定义\n```\nbool property_exists ( mixed $class , string $property )检查类的属性是否存在，例如：\n\n$directory=new Directory;\nif(!property_exists($directory,\'li\')){\n    echo \'未定义li属性！\';\n```', '1', null, '1569483020');
INSERT INTO `article` VALUES ('29', '使用memcache', '1', '1', '<h4 id=\"h4-php-memcache-\"><a name=\"php的memcache的基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>php的memcache的基本操作</h4><blockquote>\n<p>set():设置一的key给它赋值<br>set(key,val,zip,expire)<br>key:键名<br>val:键值<br>zip:数据是否压缩，压缩：MEMCACHE_COMPRESSED<br>expire:过期时间，0：永不过期<br>add():添加一个key给它赋值，它只能添加一个键名，不能添加一个已经存在的键名。<br>get():得到Key的值<br>replace():修改一个key的值<br>delete();删除一个Key的值<br>increment:给一个键名增加值<br>decrement:给一个键名减去值\n</blockquote>\n<p>创建一个memcache对象</p>\n<pre><code>$memcache = new Memcache();\n$mem_str = \"hot_items\";\n$data = $memcache-&gt;get(md5($mem_str));\nif (!$data){\n$data = Db::table(\'items\')-&gt;where(\'is_hot\',1)-&gt;select();\n}\nreturn $data;\n</code></pre><p>项目实例：<br>main.php\n<pre><code>&lt;?php\n$body_class = \'index\';\n// force remove cache if get the clear_cache parameter\n$clear_cache = _get(\'clear_cache\', null);\nif ($clear_cache) {\n    HomeHotGamesCache::removeHotGames(\'home-new-games\');\n    HomeHotGamesCache::removeHotGames(\'mobile\');\n    HomeHotGamesCache::removeHotGames(\'pc\');\n    HomeHotGamesCache::removeHotGames(\'console\');\n    HomeHotGamesCache::removeHotGames(\'multi-plat\');\n}\n\n//7 hot search game\n$hot_search_game_pairs = get_hot_search_game_pairs();\n//4 new game\n$limit = 6;\nif ($cache = HomeHotGamesCache::getHotGames(\'home-new-games\')) {\n    $home_new_games = $cache;\n} else {\n    $home_new_games = get_home_new_games($limit);\n    if ($home_new_games) {\n        HomeHotGamesCache::setHotGames(\'home-new-games\', $home_new_games);\n    }\n}\n\n//home right adv\n//$home_advs = get_showAdv(\'home_right\', $page_language);\n\n//home game\n$home_games = get_home_games(8);\n\n//home banner\n$banner_advs = get_advs(\'home_scroll\', $page_language);\n\n//news\n$news_list = get_news_list();\n\n//推广商品\n$items = get_home_items();\n\n//Popular Mobile Games\nif ($cache = HomeHotGamesCache::getHotGames(\'mobile\')) {\n    $pop_mobile_games = $cache;\n} else {\n    $pop_mobile_games = get_home_pop_games(\'mobile\');\n    if ($pop_mobile_games) {\n        HomeHotGamesCache::setHotGames(\'mobile\', $pop_mobile_games);\n    }\n}\n//Popular Computer Games\nif ($cache = HomeHotGamesCache::getHotGames(\'pc\')) {\n    $pop_pc_games = $cache;\n} else {\n    $pop_pc_games = get_home_pop_games(\'pc\');\n    if ($pop_pc_games) {\n        HomeHotGamesCache::setHotGames(\'pc\', $pop_pc_games);\n    }\n}\n//Popular Console Games\nif ($cache = HomeHotGamesCache::getHotGames(\'console\')) {\n    $pop_console_games = $cache;\n} else {\n    $pop_console_games = get_home_pop_games(\'console\');\n    if ($pop_console_games) {\n        HomeHotGamesCache::setHotGames(\'console\', $pop_console_games);\n    }\n}\n//Popular Multiplatform Games\nif ($cache = HomeHotGamesCache::getHotGames(\'multi-plat\')) {\n    $pop_multi_games = $cache;\n} else {\n    $pop_multi_games = get_home_pop_games(\'multi-plat\');\n    if ($pop_multi_games) {\n        HomeHotGamesCache::setHotGames(\'multi-plat\', $pop_multi_games);\n    }\n}\n\ninclude tpl(__FILE__);\n</code></pre><p>HomeHotGamesCache.php</p>\n<pre><code>class HomeHotGamesCache extends BaseCache\n{\n\n    // 热销游戏缓存24小时\n    public static function setHotGames($hotKey, $games)\n    {\n        return self::setCache($hotKey, json_encode($games), 86400);\n    }\n\n    public static function getHotGames($hotKey)\n    {\n        $result = self::getCache($hotKey);\n        if ($result) {\n            return json_decode($result, true);\n        }\n        return [];\n    }\n\n    public static function removeHotGames($hotKey)\n    {\n        return self::deleteCache($hotKey);\n    }\n\n}\n</code></pre><p>BaseCache.php</p>\n<pre><code>class BaseCache\n{\n\n    private static $prefix = \'kaleoz-store\';\n\n    private static function handler()\n    {\n        return Tuki_Memcache::getInstance(config(\'memcache\'));\n    }\n\n    protected static function getCache($dataId)\n    {\n        return self::handler()-&gt;get(self::getDataKey($dataId));\n    }\n\n    protected static function setCache($dataId, $data, $expire = 0)\n    {\n        return self::handler()-&gt;set(self::getDataKey($dataId), $data, $expire);\n    }\n\n    protected static function deleteCache($dataId)\n    {\n        return self::handler()-&gt;rm(self::getDataKey($dataId));\n    }\n\n    protected static function getDataKey($dataId)\n    {\n        return self::$prefix . \':\' . rtrim(self::getCacheKey(), \':\') . \':\' . $dataId;\n    }\n\n    private static function getCacheKey()\n    {\n        $cacheKey = preg_replace_callback(\'/([A-Z])/\', function ($matches) {\n            return \'-\' . strtolower($matches[1]);\n        }, get_called_class());\n        $cacheKey = ltrim($cacheKey, \'-\');\n        if (substr($cacheKey, -5) == \'cache\') {\n            $cacheKey = substr($cacheKey, 0, -5);\n            $cacheKey = rtrim($cacheKey, \'-\');\n        }\n        return $cacheKey;\n    }\n\n}\n</code></pre><p>Tuki_memcache.php</p>\n<pre><code>&lt;?php\nclass Tuki_Memcache\n{\n    const expired4hours = 4*60*60; //缓存4小时\n    protected static $_instance = null;\n    protected $_skin_hash_data = null;\n    private $_expired;\n    private $_client;\n    public $js;\n    public $css;\n\n    public static function getInstance($config = null)\n    {\n        if (null === self::$_instance) {\n            self::$_instance = new self($config);\n        }\n\n        return self::$_instance;\n    }\n\n    public function __construct($config)\n    {\n        if (null == $config) {\n            throw new Exception(\"Memcache don\'t init\");\n        }\n\n        $this-&gt;_expired = $config[\'expired\'];\n\n        $this-&gt;_client = new Memcached();\n        $this-&gt;_client-&gt;addServer($config[\'host\'], $config[\'port\']);\n    }\n\n    public function getSkinFile($file)\n    {\n        if (is_null($this-&gt;_skin_hash_data)) {\n            $this-&gt;_skin_hash_data = json_decode($this-&gt;get(\'skin_hash_data\'), true);\n        }\n        if (isset($this-&gt;_skin_hash_data[$file])) {\n            return $this-&gt;_skin_hash_data[$file];\n        } else {\n            return \'\';\n        }\n    }\n\n    public function getStatic($key)\n    {\n        if ($key == \'js\') {\n            return $this-&gt;js;\n        } elseif ($key == \'css\') {\n            return $this-&gt;css;\n        } else {\n            return false;\n        }\n    }\n\n    public function setStatic($key, $value, $expired=0)\n    {\n        $this-&gt;_client-&gt;set($key, $value, $expired&gt;0 ? $expired : $this-&gt;_expired);\n    }\n\n    public function saveUserSessID($user_id, $sess_id, $expired=0)\n    {\n        if ($user_id &gt; GUEST_USER_ID) {\n            $this-&gt;_client-&gt;set($user_id, $sess_id, $expired&gt;0 ? $expired : $this-&gt;_expired);\n        }\n    }\n\n    public function getUserSessID($user_id)\n    {\n        if ($user_id &gt; GUEST_USER_ID) {\n            return $this-&gt;_client-&gt;get($this-&gt;_client, $user_id);\n        }\n\n        return \'\';\n    }\n\n    public function set($name, $value, $expired=0)\n    {\n        return $this-&gt;_client-&gt;set($name, $value, $expired&gt;0 ? $expired : $this-&gt;_expired);\n    }\n\n    public function get($name, $val = null)\n    {\n        return $this-&gt;_client-&gt;get($name);\n    }\n\n    public function rm($name)\n    {\n        return $this-&gt;_client-&gt;delete($name);\n    }\n\n    public function __destruct()\n    {\n    }\n}\n</code></pre>', '#### php的memcache的基本操作\n> set():设置一的key给它赋值\nset(key,val,zip,expire)\nkey:键名\nval:键值\nzip:数据是否压缩，压缩：MEMCACHE_COMPRESSED\nexpire:过期时间，0：永不过期\nadd():添加一个key给它赋值，它只能添加一个键名，不能添加一个已经存在的键名。\nget():得到Key的值\nreplace():修改一个key的值\ndelete();删除一个Key的值\nincrement:给一个键名增加值\ndecrement:给一个键名减去值\n\n创建一个memcache对象\n\n```\n$memcache = new Memcache();\n$mem_str = \"hot_items\";\n$data = $memcache->get(md5($mem_str));\nif (!$data){\n$data = Db::table(\'items\')->where(\'is_hot\',1)->select();\n}\nreturn $data;\n```\n\n项目实例：\nmain.php\n```\n<?php\n$body_class = \'index\';\n// force remove cache if get the clear_cache parameter\n$clear_cache = _get(\'clear_cache\', null);\nif ($clear_cache) {\n    HomeHotGamesCache::removeHotGames(\'home-new-games\');\n    HomeHotGamesCache::removeHotGames(\'mobile\');\n    HomeHotGamesCache::removeHotGames(\'pc\');\n    HomeHotGamesCache::removeHotGames(\'console\');\n    HomeHotGamesCache::removeHotGames(\'multi-plat\');\n}\n\n//7 hot search game\n$hot_search_game_pairs = get_hot_search_game_pairs();\n//4 new game\n$limit = 6;\nif ($cache = HomeHotGamesCache::getHotGames(\'home-new-games\')) {\n    $home_new_games = $cache;\n} else {\n    $home_new_games = get_home_new_games($limit);\n    if ($home_new_games) {\n        HomeHotGamesCache::setHotGames(\'home-new-games\', $home_new_games);\n    }\n}\n\n//home right adv\n//$home_advs = get_showAdv(\'home_right\', $page_language);\n\n//home game\n$home_games = get_home_games(8);\n\n//home banner\n$banner_advs = get_advs(\'home_scroll\', $page_language);\n\n//news\n$news_list = get_news_list();\n\n//推广商品\n$items = get_home_items();\n\n//Popular Mobile Games\nif ($cache = HomeHotGamesCache::getHotGames(\'mobile\')) {\n    $pop_mobile_games = $cache;\n} else {\n    $pop_mobile_games = get_home_pop_games(\'mobile\');\n    if ($pop_mobile_games) {\n        HomeHotGamesCache::setHotGames(\'mobile\', $pop_mobile_games);\n    }\n}\n//Popular Computer Games\nif ($cache = HomeHotGamesCache::getHotGames(\'pc\')) {\n    $pop_pc_games = $cache;\n} else {\n    $pop_pc_games = get_home_pop_games(\'pc\');\n    if ($pop_pc_games) {\n        HomeHotGamesCache::setHotGames(\'pc\', $pop_pc_games);\n    }\n}\n//Popular Console Games\nif ($cache = HomeHotGamesCache::getHotGames(\'console\')) {\n    $pop_console_games = $cache;\n} else {\n    $pop_console_games = get_home_pop_games(\'console\');\n    if ($pop_console_games) {\n        HomeHotGamesCache::setHotGames(\'console\', $pop_console_games);\n    }\n}\n//Popular Multiplatform Games\nif ($cache = HomeHotGamesCache::getHotGames(\'multi-plat\')) {\n    $pop_multi_games = $cache;\n} else {\n    $pop_multi_games = get_home_pop_games(\'multi-plat\');\n    if ($pop_multi_games) {\n        HomeHotGamesCache::setHotGames(\'multi-plat\', $pop_multi_games);\n    }\n}\n\ninclude tpl(__FILE__);\n```\nHomeHotGamesCache.php\n```\nclass HomeHotGamesCache extends BaseCache\n{\n\n    // 热销游戏缓存24小时\n    public static function setHotGames($hotKey, $games)\n    {\n        return self::setCache($hotKey, json_encode($games), 86400);\n    }\n\n    public static function getHotGames($hotKey)\n    {\n        $result = self::getCache($hotKey);\n        if ($result) {\n            return json_decode($result, true);\n        }\n        return [];\n    }\n\n    public static function removeHotGames($hotKey)\n    {\n        return self::deleteCache($hotKey);\n    }\n\n}\n```\nBaseCache.php\n```\nclass BaseCache\n{\n\n    private static $prefix = \'kaleoz-store\';\n\n    private static function handler()\n    {\n        return Tuki_Memcache::getInstance(config(\'memcache\'));\n    }\n\n    protected static function getCache($dataId)\n    {\n        return self::handler()->get(self::getDataKey($dataId));\n    }\n\n    protected static function setCache($dataId, $data, $expire = 0)\n    {\n        return self::handler()->set(self::getDataKey($dataId), $data, $expire);\n    }\n\n    protected static function deleteCache($dataId)\n    {\n        return self::handler()->rm(self::getDataKey($dataId));\n    }\n\n    protected static function getDataKey($dataId)\n    {\n        return self::$prefix . \':\' . rtrim(self::getCacheKey(), \':\') . \':\' . $dataId;\n    }\n\n    private static function getCacheKey()\n    {\n        $cacheKey = preg_replace_callback(\'/([A-Z])/\', function ($matches) {\n            return \'-\' . strtolower($matches[1]);\n        }, get_called_class());\n        $cacheKey = ltrim($cacheKey, \'-\');\n        if (substr($cacheKey, -5) == \'cache\') {\n            $cacheKey = substr($cacheKey, 0, -5);\n            $cacheKey = rtrim($cacheKey, \'-\');\n        }\n        return $cacheKey;\n    }\n\n}\n```\nTuki_memcache.php\n```\n<?php\nclass Tuki_Memcache\n{\n    const expired4hours = 4*60*60; //缓存4小时\n    protected static $_instance = null;\n    protected $_skin_hash_data = null;\n    private $_expired;\n    private $_client;\n    public $js;\n    public $css;\n\n    public static function getInstance($config = null)\n    {\n        if (null === self::$_instance) {\n            self::$_instance = new self($config);\n        }\n\n        return self::$_instance;\n    }\n\n    public function __construct($config)\n    {\n        if (null == $config) {\n            throw new Exception(\"Memcache don\'t init\");\n        }\n\n        $this->_expired = $config[\'expired\'];\n\n        $this->_client = new Memcached();\n        $this->_client->addServer($config[\'host\'], $config[\'port\']);\n    }\n\n    public function getSkinFile($file)\n    {\n        if (is_null($this->_skin_hash_data)) {\n            $this->_skin_hash_data = json_decode($this->get(\'skin_hash_data\'), true);\n        }\n        if (isset($this->_skin_hash_data[$file])) {\n            return $this->_skin_hash_data[$file];\n        } else {\n            return \'\';\n        }\n    }\n\n    public function getStatic($key)\n    {\n        if ($key == \'js\') {\n            return $this->js;\n        } elseif ($key == \'css\') {\n            return $this->css;\n        } else {\n            return false;\n        }\n    }\n\n    public function setStatic($key, $value, $expired=0)\n    {\n        $this->_client->set($key, $value, $expired>0 ? $expired : $this->_expired);\n    }\n\n    public function saveUserSessID($user_id, $sess_id, $expired=0)\n    {\n        if ($user_id > GUEST_USER_ID) {\n            $this->_client->set($user_id, $sess_id, $expired>0 ? $expired : $this->_expired);\n        }\n    }\n\n    public function getUserSessID($user_id)\n    {\n        if ($user_id > GUEST_USER_ID) {\n            return $this->_client->get($this->_client, $user_id);\n        }\n\n        return \'\';\n    }\n\n    public function set($name, $value, $expired=0)\n    {\n        return $this->_client->set($name, $value, $expired>0 ? $expired : $this->_expired);\n    }\n\n    public function get($name, $val = null)\n    {\n        return $this->_client->get($name);\n    }\n\n    public function rm($name)\n    {\n        return $this->_client->delete($name);\n    }\n\n    public function __destruct()\n    {\n    }\n}\n\n```', '1', null, '1569571808');

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `code` varchar(50) DEFAULT NULL,
  `created` int(11) DEFAULT NULL,
  `update` int(11) DEFAULT NULL,
  `deleted` int(1) DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', 'PHP', 'php', null, null, '1');
INSERT INTO `category` VALUES ('2', 'Javascript', 'javascript', null, null, '1');
INSERT INTO `category` VALUES ('3', 'MySql', 'mysql', null, null, '1');
INSERT INTO `category` VALUES ('4', 'Linux', 'linux', null, null, '1');
INSERT INTO `category` VALUES ('5', 'Python', 'phthon', null, null, '1');
INSERT INTO `category` VALUES ('6', 'Go', 'go', null, null, '1');
INSERT INTO `category` VALUES ('7', 'Vue', 'vue', null, null, '1');
INSERT INTO `category` VALUES ('8', 'test', 'test', '1568103093', null, '0');
INSERT INTO `category` VALUES ('16', 'test', 'tse', '1568105211', null, '0');
INSERT INTO `category` VALUES ('15', 'test', 'test', '1568105103', null, '0');
INSERT INTO `category` VALUES ('14', 'test', 'test', '1568104956', null, '0');
INSERT INTO `category` VALUES ('17', 'test', 'test', '1568105357', null, '0');
INSERT INTO `category` VALUES ('18', 'test', 'tse', '1568105372', null, '0');
INSERT INTO `category` VALUES ('19', 'aaaa', 'aaa', '1568105452', null, '0');
INSERT INTO `category` VALUES ('20', 'test', 'test', '1568709492', null, '0');
INSERT INTO `category` VALUES ('21', 'test', 'test', '1568709669', null, '0');
